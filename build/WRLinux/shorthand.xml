<?xml version="1.0"?>
<Benchmark xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xhtml="http://www.w3.org/1999/xhtml" xmlns:dc="http://purl.org/dc/elements/1.1/" id="product-name" xsi:schemaLocation="http://checklists.nist.gov/xccdf/1.1 xccdf-1.1.4.xsd" style="SCAP_1.1" resolved="false" xml:lang="en-US">
  <status date="2011-12-20">draft</status>
  <title>Guide to the Secure Configuration of <product-name-macro/></title>
  <description>This guide presents a catalog of security-relevant
configuration settings for <product-name-macro/>. It is a rendering of
content structured in the eXtensible Configuration Checklist Description Format (XCCDF)
in order to support security automation.  The SCAP content is
is available in the <tt>scap-security-guide</tt> package which is developed at
<weblink-macro link="https://www.open-scap.org/security-policies/scap-security-guide"/>.
<br/>
<br/>
Providing system administrators with such guidance informs them how to securely
configure systems under their control in a variety of network roles. Policy
makers and baseline creators can use this catalog of settings, with its
associated references to higher-level security control catalogs, in order to
assist them in security baseline creation. This guide is a <i>catalog, not a
checklist,</i> and satisfaction of every item is not likely to be possible or
sensible in many operational scenarios. However, the XCCDF format enables
granular selection and adjustment of settings, and their association with OVAL
and OCIL content provides an automated checking capability. Transformations of
this document, and its associated automated checking content, are capable of
providing baselines that meet a diverse set of policy objectives. Some example
XCCDF <i>Profiles</i>, which are selections of items that form checklists and
can be used as baselines, are available with this guide. They can be
processed, in an automated fashion, with tools that support the Security
Content Automation Protocol (SCAP). The DISA STIG for <product-name-macro/>,
which provides required settings for US Department of Defense systems, is
one example of a baseline created from this guidance.
</description>
  <notice id="terms_of_use">Do not attempt to implement any of the settings in
this guide without first testing them in a non-operational environment. The
creators of this guidance assume no responsibility whatsoever for its use by
other parties, and makes no guarantees, expressed or implied, about its
quality, reliability, or any other characteristic.</notice>
  <front-matter xmlns:xccdf="http://checklists.nist.gov/xccdf/1.1">
    <p>
      <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" id="Layer_1" xml:space="preserve" height="140px" viewBox="30 100 330 150" width="350px" version="1.1" y="0px" x="0px" enable-background="new 30 100 330 150">
        <g fill="#3A3B3B">
          <path d="m197.1 150.3s-10.1-1.2-14.4-1.2c-7.2 0-11.0 2.6-11.0 8.3 0 6.6 3.5 7.7 12.3 9.6 10.1 2.3 14.5 4.7 14.5 13.6 0 11.2-6.1 15.6-16.1 15.6-6.0 0-16.0-1.6-16.0-1.6l0.6-4.7s9.9 1.3 15.1 1.3c7.2 0 10.8-3.1 10.8-10.2 0-5.7-3.0-7.3-11.2-8.9-10.4-2.3-15.7-4.7-15.7-14.4 0-9.8 6.4-13.6 16.3-13.6 6.0 0 15.3 1.5 15.3 1.5l-0.5 4.8z"/>
          <path d="m238.7 194.6c-3.6 0.7-9.1 1.5-13.9 1.5-15.1 0-18.5-9.2-18.5-25.9 0-17.1 3.3-26.1 18.5-26.1 5.2 0 10.7 1.0 13.9 1.6l-0.2 4.7c-3.3-0.6-9.2-1.3-13.1-1.3-11.2 0-13.2 6.7-13.2 21.1 0 14.1 1.8 20.8 13.4 20.8 4.1 0 9.5-0.7 13.0-1.3l0.2 4.8z"/>
          <path d="m257.5 144.9h12.3l13.9 50.5h-5.6l-3.7-13.0h-21.6l-3.7 13.0h-5.5l13.9-50.5zm-3.4 32.5h19.1l-7.7-27.7h-3.8l-7.7 27.7z"/>
          <path d="m297.2 178.4v17.0h-5.6v-50.5h18.5c11.0 0 16.1 5.3 16.1 16.3 0 11.0-5.1 17.2-16.1 17.2h-12.9zm12.8-5.0c7.4 0 10.4-4.5 10.4-12.3 0-7.7-3.1-11.3-10.4-11.3h-12.8v23.6h12.8z"/>
        </g>
        <g fill="#676767">
          <path d="m176.8 211.2s-2.8-0.3-4.0-0.3c-1.5 0-2.2 0.5-2.2 1.4 0 0.9 0.5 1.2 2.8 1.9 2.9 0.9 3.8 1.8 3.8 4.0 0 3.0-2.0 4.3-4.7 4.3-1.9 0-4.5-0.6-4.5-0.6l0.3-2.1s2.7 0.4 4.1 0.4c1.5 0 2.1-0.7 2.1-1.8 0-0.8-0.5-1.2-2.4-1.8-3.1-0.9-4.2-1.9-4.2-4.1 0-2.8 1.9-4.0 4.6-4.0 1.8 0 4.5 0.5 4.5 0.5l-0.2 2.2z"/>
          <path d="m180.6 208.7h8.8v2.4h-6.0v3.2h4.8v2.4h-4.9v3.3h6.0v2.4h-8.8v-13.6z"/>
          <path d="m201.2 222.1c-0.9 0.2-2.7 0.5-4.0 0.5-4.2 0-5.2-2.3-5.2-7.0 0-5.2 1.2-7.0 5.2-7.0 1.4 0 3.1 0.3 4.0 0.5l-0.1 2.2c-0.9-0.1-2.6-0.3-3.5-0.3-2.1 0-2.8 0.7-2.8 4.6 0 3.7 0.5 4.6 2.8 4.6 0.9 0 2.6-0.2 3.4-0.3l0.1 2.3z"/>
          <path d="m209.5 220.2c1.6 0 2.4-0.8 2.4-2.4v-9.1h2.8v9.0c0 3.4-1.8 4.8-5.2 4.8-3.4 0-5.2-1.4-5.2-4.8v-9.0h2.8v9.1c0 1.6 0.8 2.4 2.4 2.4z"/>
          <path d="m221.3 217.8v4.6h-2.8v-13.6h5.3c3.1 0 4.8 1.4 4.8 4.5 0 1.9-0.8 3.1-2.0 3.9l1.9 5.2h-3.0l-1.6-4.6h-2.7zm2.5-6.7h-2.5v4.3h2.6c1.4 0 1.9-1.0 1.9-2.2 0-1.3-0.7-2.2-2.0-2.2z"/>
          <path d="m231.9 208.7h2.8v13.6h-2.8v-13.6z"/>
          <path d="m237.4 208.7h10.0v2.4h-3.6v11.2h-2.8v-11.2h-3.6v-2.4z"/>
          <path d="m255.7 222.3h-2.8v-5.5l-4.2-8.1h3.1l2.5 5.4 2.5-5.4h3.1l-4.2 8.1v5.5z"/>
          <path d="m273.4 215.1h4.0v7.1s-2.9 0.5-4.6 0.5c-4.4 0-5.6-2.5-5.6-7.0 0-5.0 1.4-7.0 5.5-7.0 2.1 0 4.7 0.6 4.7 0.6l-0.1 2.1s-2.4-0.3-4.2-0.3c-2.4 0-3.1 0.8-3.1 4.6 0 3.6 0.5 4.6 3.0 4.6 0.8 0 1.7-0.1 1.7-0.1v-2.6h-1.2v-2.4z"/>
          <path d="m286 220.2c1.6 0 2.4-0.8 2.4-2.4v-9.1h2.8v9.0c0 3.4-1.8 4.8-5.2 4.8s-5.2-1.4-5.2-4.8v-9.0h2.8v9.1c0 1.6 0.8 2.4 2.4 2.4z"/>
          <path d="m295.0 208.7h2.8v13.6h-2.8v-13.6z"/>
          <path d="m301.8 222.3v-13.6h4.6c4.7 0 5.8 2.0 5.6 6.5 0 4.6-0.9 7.1-5.8 7.1h-4.6zm4.6-11.2h-1.8v8.8h1.8c2.7 0 2.9-1.6 2.9-4.7 0-3.0-0.3-4.1-3.0-4.1z"/>
          <path d="m315.5 208.7h8.8v2.4h-6.0v3.2h4.8v2.4h-4.8v3.3h6.0v2.4h-8.8v-13.6z"/>
        </g>
        <path d="m116.0 204.9h-2.8c-1.5 0-2.8 1.2-2.8 2.7v19.2c0 1.5 1.3 2.7 2.8 2.7h27.9c1.5 0 2.8-1.2 2.8-2.7v-19.2c0-1.5-1.3-2.7-2.8-2.7h-2.8v-8.2c0-6.1-5.0-11.0-11.2-11.0-6.2 0-11.2 4.9-11.2 11.0v8.2zm5.6-8.2c0-3.0 2.5-5.5 5.6-5.4 3.1 0 5.6 2.4 5.6 5.5v8.2h-11.2v-8.2z" fill="#6D0B2B"/>
        <g fill="#AD1D3F">
          <path d="m106.4 214.7c-16.4 11.4-37.5 7.8-50.0-3.4l11.9-11.7c2.3-1.9 3.4-5.4 1.2-8.8-0.1-0.1-6.7-11.0 2.3-19.8 7.3-7.2 17.8-5.8 23.3-0.3 3.2 3.1 4.9 7.1 4.9 11.4v0.1c0 4.3-1.8 8.5-5.1 11.7-4.0 3.9-9.6 5.4-15.4 4.1-2.1-0.5-4.3 0.8-4.8 2.9-0.5 2.1 0.8 4.2 2.9 4.7 8.4 2.0 16.9-0.3 22.8-6.1 4.9-4.8 7.5-10.9 7.4-17.4-0.0-6.3-2.6-12.3-7.3-16.8-8.2-8.1-23.8-10.3-34.5 0.3-10.7 10.5-6.6 23.8-3.7 28.8l-12.8 12.6c-2.9 2.9-2.3 6.6-0.2 8.7 15.4 15.2 38.7 17.9 56.9 8.2l-0.0-9.1z"/>
          <path d="m43.9 188.4c-1.1-7.5-1.1-21.8 11.2-33.9 8.0-7.9 18.5-12.0 29.5-11.7 10.2 0.3 20.1 4.5 27.1 11.4 7.6 7.4 11.8 17.3 11.9 27.8v0.1c1.16-0.3 2.4-0.4 3.6-0.4 1.5 0 2.9 0.2 4.3 0.6 0-0.1 0.0-0.2 0.0-0.3-0.1-12.5-5.2-24.3-14.2-33.2-8.4-8.3-20.2-13.3-32.4-13.7-13.2-0.5-25.8 4.5-35.4 14.0-9.1 8.9-14.0 20.8-14.0 33.3 0 2.4 0.2 4.8 0.5 7.2 0.6 4.0 1.8 8.1 3.7 12.2 0.9 2.0 3.2 2.8 5.2 1.9 2.0-0.9 2.9-3.1 2.0-5.1-1.5-3.3-2.6-6.8-3.1-10.1z"/>
        </g>
        <circle cy="218.49" cx="127.26" r="3.233" fill="#fff"/>
      </svg>
    </p>
  </front-matter>
  <rear-matter>Red Hat and Red Hat Enterprise Linux are either registered
trademarks or trademarks of Red Hat, Inc. in the United States and other
countries. All other names are registered trademarks or trademarks of their
respective companies.</rear-matter>
  <platform-cpes-macro/>
  <version>0.9</version>
  <metadata/>
  <Profile id="basic-embedded">
    <title>Basic Profile for Embedded Systems</title>
    <description>
This profile contains items common to many embedded Linux installations.
Regardless of your system's deployment objective, all of these checks should pass.
</description>
    <refine-value idref="sshd_idle_timeout_value" selector="10_minutes"/>
    <refine-value idref="var_accounts_fail_delay" selector="4"/>
    <refine-value idref="var_accounts_passwords_pam_faillock_deny" selector="3"/>
    <refine-value idref="var_accounts_passwords_pam_faillock_unlock_time" selector="604800"/>
    <refine-value idref="var_accounts_user_umask" selector="077"/>
    <refine-value idref="var_auditd_action_mail_acct" selector="root"/>
    <refine-value idref="var_auditd_max_log_file_action" selector="rotate"/>
    <refine-value idref="var_auditd_num_logs" selector="5"/>
    <refine-value idref="var_auditd_space_left_action" selector="email"/>
    <refine-value idref="var_selinux_policy_name" selector="targeted"/>
    <select idref="accounts_logon_fail_delay" selected="true"/>
    <select idref="accounts_max_concurrent_login_sessions" selected="true"/>
    <select idref="accounts_no_uid_except_zero" selected="true"/>
    <select idref="accounts_password_all_shadowed" selected="true"/>
    <select idref="accounts_root_path_dirs_no_write" selected="true"/>
    <select idref="accounts_umask_etc_login_defs" selected="true"/>
    <select idref="accounts_umask_etc_profile" selected="true"/>
    <select idref="file_permissions_home_dirs" selected="true"/>
    <select idref="no_empty_passwords" selected="true"/>
    <select idref="no_netrc_files" selected="true"/>
    <select idref="root_path_no_dot" selected="true"/>
    <!--
The following are targeted for a possible future basic-embedded addition.
For now, they don't work.
-->
    <!-- <select idref="dir_perms_world_writable_sticky_bits" selected="true" /> -->
    <!-- <select idref="file_permissions_unauthorized_sgid" selected="true" /> -->
    <!-- <select idref="file_permissions_unauthorized_suid" selected="true" /> -->
    <!-- <select idref="file_permissions_unauthorized_world_writable" selected="true" /> -->
    <!-- <select idref="mount_option_dev_shm_nodev" selected="true" /> -->
    <!-- <select idref="mount_option_dev_shm_noexec" selected="true" /> -->
    <!-- <select idref="mount_option_dev_shm_nosuid" selected="true" /> -->
    <!-- <select idref="service_abrtd_disabled" selected="true" /> -->
    <!-- <select idref="service_atd_disabled" selected="true" /> -->
    <!-- <select idref="service_autofs_disabled" selected="true" /> -->
    <!-- <select idref="service_ntpdate_disabled" selected="true" /> -->
    <!-- <select idref="service_oddjobd_disabled" selected="true" /> -->
    <!-- <select idref="service_qpidd_disabled" selected="true" /> -->
    <!-- <select idref="service_rdisc_disabled" selected="true" /> -->
  </Profile>
  <Value id="conditional_clause" type="string" operator="equals">
    <title>A conditional clause for check statements.</title>
    <description>A conditional clause for check statements.</description>
    <value>This is a placeholder.</value>
  </Value>
  <Group id="remediation_functions">
    <title>Remediation functions used by the SCAP Security Guide Project</title>
    <description>XCCDF form of the various remediation functions as used by
remediation scripts from the SCAP Security Guide Project</description>
    <Value id="function_fix_audit_syscall_rule" type="string" operator="equals" interactive="0" hidden="true" prohibitChanges="true">
      <title>Remediation function to fix syscall audit rule for given system call</title>
      <description>Function to fix syscall audit rule for given system call. It is
based on example audit syscall rule definitions as outlined in
/usr/share/doc/audit-2.3.7/stig.rules file provided with the audit package. It
will combine multiple system calls belonging to the same syscall group into one
audit rule (rather than to create audit rule per different system call) to
avoid audit infrastructure performance penalty in the case of
'one-audit-rule-definition-per-one-system-call'. See:

	https://www.redhat.com/archives/linux-audit/2014-November/msg00009.html

for further details.

Expects five arguments (each of them is required) in the form of:
  * audit tool                          tool used to load audit rules,
                                        either 'auditctl', or 'augenrules
  * audit rules' pattern                audit rule skeleton for same syscall
  * syscall group                       greatest common string this rule shares
                                        with other rules from the same group
  * architecture                        architecture this rule is intended for
  * full form of new rule to add        expected full form of audit rule as to
                                        be added into audit.rules file

Note: The 2-th up to 4-th arguments are used to determine how many existing
audit rules will be inspected for resemblance with the new audit rule
(5-th argument) the function is going to add. The rule's similarity check
is performed to optimize audit.rules definition (merge syscalls of the same
group into one rule) to avoid the "single-syscall-per-audit-rule" performance
penalty.

Example call:

  PATTERN="-a always,exit -F arch=$ARCH -S .* -F auid&gt;=500 -F auid!=4294967295 -k delete"
  # Use escaped BRE regex to specify rule group
  GROUP="\(rmdir\|unlink\|rename\)"
  FULL_RULE="-a always,exit -F arch=$ARCH -S rmdir -S unlink -S unlinkat -S rename -S renameat -F auid&gt;=500 -F auid!=4294967295 -k delete"
  fix_audit_syscall_rule "auditctl" "$PATTERN" "$GROUP" "$ARCH" "$FULL_RULE"
</description>
      <value selector="">
function fix_audit_syscall_rule {

# Load function arguments into local variables
local tool="$1"
local pattern="$2"
local group="$3"
local arch="$4"
local full_rule="$5"

# Check sanity of the input
if [ $# -ne "5" ]
then
        echo "Usage: fix_audit_syscall_rule 'tool' 'pattern' 'group' 'arch' 'full rule'"
        echo "Aborting."
        exit 1
fi

# Create a list of audit *.rules files that should be inspected for presence and correctness
# of a particular audit rule. The scheme is as follows:
#
# -----------------------------------------------------------------------------------------
#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |
# -----------------------------------------------------------------------------------------
#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |
# -----------------------------------------------------------------------------------------
#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |
#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |
# -----------------------------------------------------------------------------------------
#
declare -a files_to_inspect

# First check sanity of the specified audit tool
if [ "$tool" != 'auditctl' ] &amp;&amp; [ "$tool" != 'augenrules' ]
then
        echo "Unknown audit rules loading tool: $1. Aborting."
        echo "Use either 'auditctl' or 'augenrules'!"
        exit 1
# If audit tool is 'auditctl', then add '/etc/audit/audit.rules'
# file to the list of files to be inspected
elif [ "$tool" == 'auditctl' ]
then
        files_to_inspect=("${files_to_inspect[@]}" '/etc/audit/audit.rules' )
# If audit tool is 'augenrules', then check if the audit rule is defined
# If rule is defined, add '/etc/audit/rules.d/*.rules' to the list for inspection
# If rule isn't defined yet, add '/etc/audit/rules.d/$key.rules' to the list for inspection
elif [ "$tool" == 'augenrules' ]
then
        # Extract audit $key from audit rule so we can use it later
        key=$(expr "$full_rule" : '.*-k[[:space:]]\([^[:space:]]\+\)')
        # Check if particular audit rule is already defined
        IFS=$'\n' matches=($(sed -s -n -e "/${pattern}/!d" -e "/${arch}/!d" -e "/${group}/!d;F" /etc/audit/rules.d/*.rules))
        # Reset IFS back to default
        unset $IFS
        for match in "${matches[@]}"
        do
                files_to_inspect=("${files_to_inspect[@]}" "${match}")
        done
        # Case when particular rule isn't defined in /etc/audit/rules.d/*.rules yet
        if [ ${#files_to_inspect[@]} -eq "0" ]
        then
                files_to_inspect="/etc/audit/rules.d/$key.rules"
                if [ ! -e "$files_to_inspect" ]
                then
                        touch "$files_to_inspect"
                        chmod 0640 "$files_to_inspect"
                fi
        fi
fi

#
# Indicator that we want to append $full_rule into $audit_file by default
local append_expected_rule=0

for audit_file in "${files_to_inspect[@]}"
do

        # Filter existing $audit_file rules' definitions to select those that:
        # * follow the rule pattern, and
        # * meet the hardware architecture requirement, and
        # * are current syscall group specific
        IFS=$'\n' existing_rules=($(sed -e "/${pattern}/!d" -e "/${arch}/!d" -e "/${group}/!d"  "$audit_file"))
        # Reset IFS back to default
        unset $IFS

        # Process rules found case-by-case
        for rule in "${existing_rules[@]}"
        do
                # Found rule is for same arch &amp; key, but differs (e.g. in count of -S arguments)
                if [ "${rule}" != "${full_rule}" ]
                then
                        # If so, isolate just '(-S \w)+' substring of that rule
                        rule_syscalls=$(echo $rule | grep -o -P '(-S \w+ )+')
                        # Check if list of '-S syscall' arguments of that rule is subset
                        # of '-S syscall' list of expected $full_rule
                        if grep -q -- "$rule_syscalls" &lt;&lt;&lt; "$full_rule"
                        then
                                # Rule is covered (i.e. the list of -S syscalls for this rule is
                                # subset of -S syscalls of $full_rule =&gt; existing rule can be deleted
                                # Thus delete the rule from audit.rules &amp; our array
                                sed -i -e "/$rule/d" "$audit_file"
                                existing_rules=("${existing_rules[@]//$rule/}")
                        else
                                # Rule isn't covered by $full_rule - it besides -S syscall arguments
                                # for this group contains also -S syscall arguments for other syscall
                                # group. Example: '-S lchown -S fchmod -S fchownat' =&gt; group='chown'
                                # since 'lchown' &amp; 'fchownat' share 'chown' substring
                                # Therefore:
                                # * 1) delete the original rule from audit.rules
                                # (original '-S lchown -S fchmod -S fchownat' rule would be deleted)
                                # * 2) delete the -S syscall arguments for this syscall group, but
                                # keep those not belonging to this syscall group
                                # (original '-S lchown -S fchmod -S fchownat' would become '-S fchmod'
                                # * 3) append the modified (filtered) rule again into audit.rules
                                # if the same rule not already present
                                #
                                # 1) Delete the original rule
                                sed -i -e "/$rule/d" "$audit_file"
                                # 2) Delete syscalls for this group, but keep those from other groups
                                # Convert current rule syscall's string into array splitting by '-S' delimiter
                                IFS=$'-S' read -a rule_syscalls_as_array &lt;&lt;&lt; "$rule_syscalls"
                                # Reset IFS back to default
                                unset $IFS
                                # Declare new empty string to hold '-S syscall' arguments from other groups
                                new_syscalls_for_rule=''
                                # Walk through existing '-S syscall' arguments
                                for syscall_arg in "${rule_syscalls_as_array[@]}"
                                do
                                        # Skip empty $syscall_arg values
                                        if [ "$syscall_arg" == '' ]
                                        then
                                                continue
                                        fi
                                        # If the '-S syscall' doesn't belong to current group add it to the new list
                                        # (together with adding '-S' delimiter back for each of such item found)
                                        if grep -q -v -- "$group" &lt;&lt;&lt; "$syscall_arg"
                                        then
                                                new_syscalls_for_rule="$new_syscalls_for_rule -S $syscall_arg"
                                        fi
                                done
                                # Replace original '-S syscall' list with the new one for this rule
                                updated_rule=${rule//$rule_syscalls/$new_syscalls_for_rule}
                                # Squeeze repeated whitespace characters in rule definition (if any) into one
                                updated_rule=$(echo "$updated_rule" | tr -s '[:space:]')
                                # 3) Append the modified / filtered rule again into audit.rules
                                #    (but only in case it's not present yet to prevent duplicate definitions)
                                if ! grep -q -- "$updated_rule" "$audit_file"
                                then
                                        echo "$updated_rule" &gt;&gt; "$audit_file"
                                fi
                        fi
                else
                        # $audit_file already contains the expected rule form for this
                        # architecture &amp; key =&gt; don't insert it second time
                        append_expected_rule=1
                fi
        done

        # We deleted all rules that were subset of the expected one for this arch &amp; key.
        # Also isolated rules containing system calls not from this system calls group.
        # Now append the expected rule if it's not present in $audit_file yet
        if [[ ${append_expected_rule} -eq "0" ]]
        then
                echo "$full_rule" &gt;&gt; "$audit_file"
        fi
done

}
</value>
    </Value>
    <Value id="function_fix_audit_watch_rule" type="string" operator="equals" interactive="0" hidden="true" prohibitChanges="true">
      <title>Remediation function to fix audit file system object watch rule for given path</title>
      <description>Function to fix audit file system object watch rule for given path:
  * if rule exists, also verifies the -w bits match the requirements
  * if rule doesn't exist yet, appends expected rule form to $files_to_inspect
    audit rules file, depending on the tool which was used to load audit rules

Expects four arguments (each of them is required) in the form of:
  * audit tool                          tool used to load audit rules,
                                        either 'auditctl', or 'augenrules'
  * path                                value of -w audit rule's argument
  * required access bits                value of -p audit rule's argument
  * key                                 value of -k audit rule's argument

Example call:

  fix_audit_watch_rule "auditctl" "/etc/localtime" "wa" "audit_time_rules"
</description>
      <value selector="">
function fix_audit_watch_rule {

# Load function arguments into local variables
local tool="$1"
local path="$2"
local required_access_bits="$3"
local key="$4"

# Check sanity of the input
if [ $# -ne "4" ]
then
        echo "Usage: fix_audit_watch_rule 'tool' 'path' 'bits' 'key'"
        echo "Aborting."
        exit 1
fi

# Create a list of audit *.rules files that should be inspected for presence and correctness
# of a particular audit rule. The scheme is as follows:
#
# -----------------------------------------------------------------------------------------
# Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |
# -----------------------------------------------------------------------------------------
#       auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |
# -----------------------------------------------------------------------------------------
#       augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |
#       augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |
# -----------------------------------------------------------------------------------------
declare -a files_to_inspect

# Check sanity of the specified audit tool
if [ "$tool" != 'auditctl' ] &amp;&amp; [ "$tool" != 'augenrules' ]
then
        echo "Unknown audit rules loading tool: $1. Aborting."
        echo "Use either 'auditctl' or 'augenrules'!"
        exit 1
# If the audit tool is 'auditctl', then add '/etc/audit/audit.rules'
# into the list of files to be inspected
elif [ "$tool" == 'auditctl' ]
then
        files_to_inspect=("${files_to_inspect[@]}" '/etc/audit/audit.rules')
# If the audit is 'augenrules', then check if rule is already defined
# If rule is defined, add '/etc/audit/rules.d/*.rules' to list of files for inspection.
# If rule isn't defined, add '/etc/audit/rules.d/$key.rules' to list of files for inspection.
elif [ "$tool" == 'augenrules' ]
then
        # Case when particular audit rule is already defined in some of /etc/audit/rules.d/*.rules file
        # Get pair -- filepath : matching_row into @matches array
        IFS=$'\n' matches=($(grep -P "[\s]*-w[\s]+$path" /etc/audit/rules.d/*.rules))
        # Reset IFS back to default
        unset $IFS
        # For each of the matched entries
        for match in "${matches[@]}"
        do
                # Extract filepath from the match
                rulesd_audit_file=$(echo $match | cut -f1 -d ':')
                # Append that path into list of files for inspection
                files_to_inspect=("${files_to_inspect[@]}" "$rulesd_audit_file")
        done
        # Case when particular audit rule isn't defined yet
        if [ ${#files_to_inspect[@]} -eq "0" ]
        then
                # Append '/etc/audit/rules.d/$key.rules' into list of files for inspection
                files_to_inspect="/etc/audit/rules.d/$key.rules"
                # If the $key.rules file doesn't exist yet, create it with correct permissions
                if [ ! -e "$files_to_inspect" ]
                then
                        touch "$files_to_inspect"
                        chmod 0640 "$files_to_inspect"
                fi
        fi
fi

# Finally perform the inspection and possible subsequent audit rule
# correction for each of the files previously identified for inspection
for audit_rules_file in "${files_to_inspect[@]}"
do

        # Check if audit watch file system object rule for given path already present
        if grep -q -P -- "[\s]*-w[\s]+$path" "$audit_rules_file"
        then
                # Rule is found =&gt; verify yet if existing rule definition contains
                # all of the required access type bits

                # Escape slashes in path for use in sed pattern below
                local esc_path=${path//$'/'/$'\/'}
                # Define BRE whitespace class shortcut
                local sp="[[:space:]]"
                # Extract current permission access types (e.g. -p [r|w|x|a] values) from audit rule
                current_access_bits=$(sed -ne "s/$sp*-w$sp\+$esc_path$sp\+-p$sp\+\([rxwa]\{1,4\}\).*/\1/p" "$audit_rules_file")
                # Split required access bits string into characters array
                # (to check bit's presence for one bit at a time)
                for access_bit in $(echo "$required_access_bits" | grep -o .)
                do
                        # For each from the required access bits (e.g. 'w', 'a') check
                        # if they are already present in current access bits for rule.
                        # If not, append that bit at the end
                        if ! grep -q "$access_bit" &lt;&lt;&lt; "$current_access_bits"
                        then
                                # Concatenate the existing mask with the missing bit
                                current_access_bits="$current_access_bits$access_bit"
                        fi
                done
                # Propagate the updated rule's access bits (original + the required
                # ones) back into the /etc/audit/audit.rules file for that rule
                sed -i "s/\($sp*-w$sp\+$esc_path$sp\+-p$sp\+\)\([rxwa]\{1,4\}\)\(.*\)/\1$current_access_bits\3/" "$audit_rules_file"
        else
                # Rule isn't present yet. Append it at the end of $audit_rules_file file
                # with proper key

                echo "-w $path -p $required_access_bits -k $key" &gt;&gt; "$audit_rules_file"
        fi
done
}
</value>
    </Value>
    <Value id="function_package_command" type="string" operator="equals" interactive="0" hidden="true" prohibitChanges="true">
      <title>Remediation function to to install or uninstall packages on RHEL and Fedora systems</title>
      <description>Function to install or uninstall packages on RHEL and Fedora systems.

Example Call(s):

  package_command install aide
  package_command remove telnet-server
</description>
      <value selector="">
function package_command {

# Load function arguments into local variables
local package_operation=$1
local package=$2

# Check sanity of the input
if [ $# -ne "2" ]
then
  echo "Usage: package_command 'install/uninstall' 'rpm_package_name"
  echo "Aborting."
  exit 1
fi

# If dnf is installed, use dnf; otherwise, use yum
if [ -f "/usr/bin/dnf" ] ; then
  install_util="/usr/bin/dnf"
else
  install_util="/usr/bin/yum"
fi

if [ "$package_operation" != 'remove' ] ; then
  # If the rpm is not installed, install the rpm
  if ! /bin/rpm -q --quiet $package; then
    $install_util -y $package_operation $package
  fi
else
  # If the rpm is installed, uninstall the rpm
  if /bin/rpm -q --quiet $package; then
    $install_util -y $package_operation $package
  fi
fi

}
</value>
    </Value>
    <Value id="function_service_command" type="string" operator="equals" interactive="0" hidden="true" prohibitChanges="true">
      <title>Remediation function to enable/disable and start/stop services on RHEL
and Fedora systems</title>
      <description>Function to enable/disable and start/stop services on RHEL and
Fedora systems.

Example Call(s):

  service_command enable bluetooth
  service_command disable bluetooth.service

  Using xinetd:
  service_command disable rsh.socket xinetd=rsh
</description>
      <value selector="">
function service_command {

# Load function arguments into local variables
local service_state=$1
local service=$2
local xinetd=$(echo $3 | cut -d'=' -f2)

# Check sanity of the input
if [ $# -lt "2" ]
then
  echo "Usage: service_command 'enable/disable' 'service_name.service'"
  echo
  echo "To enable or disable xinetd services add \'xinetd=service_name\'"
  echo "as the last argument"
  echo "Aborting."
  exit 1
fi

# If systemctl is installed, use systemctl command; otherwise, use the service/chkconfig commands
if [ -f "/usr/bin/systemctl" ] ; then
  service_util="/usr/bin/systemctl"
else
  service_util="/sbin/service"
  chkconfig_util="/sbin/chkconfig"
fi

# If disable is not specified in arg1, set variables to enable services.
# Otherwise, variables are to be set to disable services.
if [ "$service_state" != 'disable' ] ; then
  service_state="enable"
  service_operation="start"
  chkconfig_state="on"
else
  service_state="disable"
  service_operation="stop"
  chkconfig_state="off"
fi

# If chkconfig_util is not empty, use chkconfig/service commands.
if ! [ "x$chkconfig_util" = x ] ; then
  $service_util $service $service_operation
  $chkconfig_util --level 0123456 $service $chkconfig_state
else
  $service_util $service_operation $service
  $service_util $service_state $service
fi

# Test if local variable xinetd is empty using non-bashism.
# If empty, then xinetd is not being used.
if ! [ "x$xinetd" = x ] ; then
  grep -qi disable /etc/xinetd.d/$xinetd &amp;&amp; \

  if ! [ "$service_operation" != 'disable' ] ; then
    sed -i "s/disable.*/disable         = no/gI" /etc/xinetd.d/$xinetd
  else
    sed -i "s/disable.*/disable         = yes/gI" /etc/xinetd.d/$xinetd
  fi
fi

}
</value>
    </Value>
    <Value id="function_perform_audit_rules_privileged_commands_remediation" type="string" operator="equals" interactive="0" hidden="true" prohibitChanges="true">
      <title>Remediation function to perform remediation for 'audit_rules_privileged_commands' rule</title>
      <description>Function to perform remediation for 'audit_rules_privileged_commands' rule

Expects two arguments:

  audit_tool            tool used to load audit rules
                        One of 'auditctl' or 'augenrules'

  min_auid              Minimum original ID the user logged in with
                        '500' for RHEL-6 and before, '1000' for RHEL-7 and after.

Example Call(s):

  perform_audit_rules_privileged_commands_remediation "auditctl" "500"
  perform_audit_rules_privileged_commands_remediation "augenrules" "1000"
</description>
      <value selector="">
function perform_audit_rules_privileged_commands_remediation {
#
# Load function arguments into local variables
local tool="$1"
local min_auid="$2"

# Check sanity of the input
if [ $# -ne "2" ]
then
        echo "Usage: perform_audit_rules_privileged_commands_remediation 'auditctl | augenrules' '500 | 1000'"
        echo "Aborting."
        exit 1
fi

declare -a files_to_inspect=()

# Check sanity of the specified audit tool
if [ "$tool" != 'auditctl' ] &amp;&amp; [ "$tool" != 'augenrules' ]
then
        echo "Unknown audit rules loading tool: $1. Aborting."
        echo "Use either 'auditctl' or 'augenrules'!"
        exit 1
# If the audit tool is 'auditctl', then:
# * add '/etc/audit/audit.rules'to the list of files to be inspected,
# * specify '/etc/audit/audit.rules' as the output audit file, where
#   missing rules should be inserted
elif [ "$tool" == 'auditctl' ]
then
        files_to_inspect=("/etc/audit/audit.rules")
        output_audit_file="/etc/audit/audit.rules"
#
# If the audit tool is 'augenrules', then:
# * add '/etc/audit/rules.d/*.rules' to the list of files to be inspected
#   (split by newline),
# * specify /etc/audit/rules.d/privileged.rules' as the output file, where
#   missing rules should be inserted
elif [ "$tool" == 'augenrules' ]
then
        IFS=$'\n' files_to_inspect=($(find /etc/audit/rules.d -maxdepth 1 -type f -name *.rules -print))
        output_audit_file="/etc/audit/rules.d/privileged.rules"
fi

# Obtain the list of SUID/SGID binaries on the particular system (split by newline)
# into privileged_binaries array
IFS=$'\n' privileged_binaries=($(find / -xdev -type f -perm -4000 -o -type f -perm -2000 2&gt;/dev/null))

# Keep list of SUID/SGID binaries that have been already handled within some previous iteration
declare -a sbinaries_to_skip=()

# For each found sbinary in privileged_binaries list
for sbinary in "${privileged_binaries[@]}"
do

        # Replace possible slash '/' character in sbinary definition so we could use it in sed expressions below
        sbinary_esc=${sbinary//$'/'/$'\/'}
        # Check if this sbinary wasn't already handled in some of the previous iterations
        # Return match only if whole sbinary definition matched (not in the case just prefix matched!!!)
        if [[ $(sed -ne "/${sbinary_esc}$/p" &lt;&lt;&lt; ${sbinaries_to_skip[@]}) ]]
        then
                # If so, don't process it second time &amp; go to process next sbinary
                continue
        fi

        # Reset the counter of inspected files when starting to check
        # presence of existing audit rule for new sbinary
        local count_of_inspected_files=0

        # For each audit rules file from the list of files to be inspected
        for afile in "${files_to_inspect[@]}"
        do

                # Search current audit rules file's content for match. Match criteria:
                # * existing rule is for the same SUID/SGID binary we are currently processing (but
                #   can contain multiple -F path= elements covering multiple SUID/SGID binaries)
                # * existing rule contains all arguments from expected rule form (though can contain
                #   them in arbitrary order)

                base_search=$(sed -e "/-a always,exit/!d" -e "/-F path=${sbinary_esc}$/!d"   \
                                  -e "/-F path=[^[:space:]]\+/!d" -e "/-F perm=.*/!d"       \
                                  -e "/-F auid&gt;=${min_auid}/!d" -e "/-F auid!=4294967295/!d"  \
                                  -e "/-k privileged/!d" $afile)

                # Increase the count of inspected files for this sbinary
                count_of_inspected_files=$((count_of_inspected_files + 1))

                # Define expected rule form for this binary
                expected_rule="-a always,exit -F path=${sbinary} -F perm=x -F auid&gt;=${min_auid} -F auid!=4294967295 -k privileged"

                # Require execute access type to be set for existing audit rule
                exec_access='x'

                # Search current audit rules file's content for presence of rule pattern for this sbinary
                if [[ $base_search ]]
                then

                        # Current audit rules file already contains rule for this binary =&gt;
                        # Store the exact form of found rule for this binary for further processing
                        concrete_rule=$base_search

                        # Select all other SUID/SGID binaries possibly also present in the found rule
                        IFS=$'\n' handled_sbinaries=($(grep -o -e "-F path=[^[:space:]]\+" &lt;&lt;&lt; $concrete_rule))
                        IFS=$' ' handled_sbinaries=(${handled_sbinaries[@]//-F path=/})

                        # Merge the list of such SUID/SGID binaries found in this iteration with global list ignoring duplicates
                        sbinaries_to_skip=($(for i in "${sbinaries_to_skip[@]}" "${handled_sbinaries[@]}"; do echo $i; done | sort -du))

                        # Separate concrete_rule into three sections using hash '#'
                        # sign as a delimiter around rule's permission section borders
                        concrete_rule=$(echo $concrete_rule | sed -n "s/\(.*\)\+\(-F perm=[rwax]\+\)\+/\1#\2#/p")

                        # Split concrete_rule into head, perm, and tail sections using hash '#' delimiter
                        IFS=$'#' read rule_head rule_perm rule_tail &lt;&lt;&lt;  "$concrete_rule"

                        # Extract already present exact access type [r|w|x|a] from rule's permission section
                        access_type=${rule_perm//-F perm=/}

                        # Verify current permission access type(s) for rule contain 'x' (execute) permission
                        if ! grep -q "$exec_access" &lt;&lt;&lt; "$access_type"
                        then

                                # If not, append the 'x' (execute) permission to the existing access type bits
                                access_type="$access_type$exec_access"
                                # Reconstruct the permissions section for the rule
                                new_rule_perm="-F perm=$access_type"
                                # Update existing rule in current audit rules file with the new permission section
                                sed -i "s#${rule_head}\(.*\)${rule_tail}#${rule_head}${new_rule_perm}${rule_tail}#" $afile

                        fi

                # If the required audit rule for particular sbinary wasn't found yet, insert it under following conditions:
                #
                # * in the "auditctl" mode of operation insert particular rule each time
                #   (because in this mode there's only one file -- /etc/audit/audit.rules to be inspected for presence of this rule),
                #
                # * in the "augenrules" mode of operation insert particular rule only once and only in case we have already
                #   searched all of the files from /etc/audit/rules.d/*.rules location (since that audit rule can be defined
                #   in any of those files and if not, we want it to be inserted only once into /etc/audit/rules.d/privileged.rules file)
                #
                elif [ "$tool" == "auditctl" ] || [[ "$tool" == "augenrules" &amp;&amp; $count_of_inspected_files -eq "${#files_to_inspect[@]}" ]]
                then

                        # Current audit rules file's content doesn't contain expected rule for this
                        # SUID/SGID binary yet =&gt; append it
                        echo $expected_rule &gt;&gt; $output_audit_file
                fi

        done

done

}
</value>
    </Value>
    <Value id="function_populate" type="string" operator="equals" interactive="0" hidden="true" prohibitChanges="true">
      <title>Remediation function to populate environment variables needed for unit testing</title>
      <description>The populate function isn't directly used by SSG at the moment but it can
ba used for testing purposes (to verify proper work of the remediation script directly
from the shell).</description>
      <value selector="">
function populate {
# Code to populate environment variables needed (for unit testing)
if [ -z "${!1}" ]; then
	echo "$1 is not defined. Exiting."
	exit
fi
}
</value>
    </Value>
    <Value id="function_rhel6_perform_audit_adjtimex_settimeofday_stime_remediation" type="string" operator="equals" interactive="0" hidden="true" prohibitChanges="true">
      <title>Remediation function for the 'adjtimex', 'settimeofday', and 'stime'
audit system calls on Red Hat Enterprise Linux 6</title>
      <description>Perform the remediation for the 'adjtimex', 'settimeofday', and 'stime' audit
# system calls on Red Hat Enterprise Linux 6 OS</description>
      <value selector="">
function fix_audit_syscall_rule {

# Load function arguments into local variables
local tool="$1"
local pattern="$2"
local group="$3"
local arch="$4"
local full_rule="$5"

# Check sanity of the input
if [ $# -ne "5" ]
then
        echo "Usage: fix_audit_syscall_rule 'tool' 'pattern' 'group' 'arch' 'full rule'"
        echo "Aborting."
        exit 1
fi

# Create a list of audit *.rules files that should be inspected for presence and correctness
# of a particular audit rule. The scheme is as follows:
# 
# -----------------------------------------------------------------------------------------
#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |
# -----------------------------------------------------------------------------------------
#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |
# -----------------------------------------------------------------------------------------
#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |
#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |
# -----------------------------------------------------------------------------------------
#
declare -a files_to_inspect

# First check sanity of the specified audit tool
if [ "$tool" != 'auditctl' ] &amp;&amp; [ "$tool" != 'augenrules' ]
then
        echo "Unknown audit rules loading tool: $1. Aborting."
        echo "Use either 'auditctl' or 'augenrules'!"
        exit 1
# If audit tool is 'auditctl', then add '/etc/audit/audit.rules'
# file to the list of files to be inspected
elif [ "$tool" == 'auditctl' ]
then
        files_to_inspect=("${files_to_inspect[@]}" '/etc/audit/audit.rules' )
# If audit tool is 'augenrules', then check if the audit rule is defined
# If rule is defined, add '/etc/audit/rules.d/*.rules' to the list for inspection
# If rule isn't defined yet, add '/etc/audit/rules.d/$key.rules' to the list for inspection
elif [ "$tool" == 'augenrules' ]
then
        # Extract audit $key from audit rule so we can use it later
        key=$(expr "$full_rule" : '.*-k[[:space:]]\([^[:space:]]\+\)')
        # Check if particular audit rule is already defined
        IFS=$'\n' matches=($(sed -s -n -e "/${pattern}/!d" -e "/${arch}/!d" -e "/${group}/!d;F" /etc/audit/rules.d/*.rules))
        # Reset IFS back to default
        unset $IFS
        for match in "${matches[@]}"
        do
                files_to_inspect=("${files_to_inspect[@]}" "${match}")
        done
        # Case when particular rule isn't defined in /etc/audit/rules.d/*.rules yet
        if [ ${#files_to_inspect[@]} -eq "0" ]
        then
                files_to_inspect="/etc/audit/rules.d/$key.rules"
                if [ ! -e "$files_to_inspect" ]
                then
                        touch "$files_to_inspect"
                        chmod 0640 "$files_to_inspect"
                fi
        fi
fi

#
# Indicator that we want to append $full_rule into $audit_file by default
local append_expected_rule=0

for audit_file in "${files_to_inspect[@]}"
do

        # Filter existing $audit_file rules' definitions to select those that:
        # * follow the rule pattern, and
        # * meet the hardware architecture requirement, and
        # * are current syscall group specific
        IFS=$'\n' existing_rules=($(sed -e "/${pattern}/!d" -e "/${arch}/!d" -e "/${group}/!d"  "$audit_file"))
        # Reset IFS back to default
        unset $IFS

        # Process rules found case-by-case
        for rule in "${existing_rules[@]}"
        do
                # Found rule is for same arch &amp; key, but differs (e.g. in count of -S arguments)
                if [ "${rule}" != "${full_rule}" ]
                then
                        # If so, isolate just '(-S \w)+' substring of that rule
                        rule_syscalls=$(echo $rule | grep -o -P '(-S \w+ )+')
                        # Check if list of '-S syscall' arguments of that rule is subset
                        # of '-S syscall' list of expected $full_rule
                        if grep -q -- "$rule_syscalls" &lt;&lt;&lt; "$full_rule"
                        then
                                # Rule is covered (i.e. the list of -S syscalls for this rule is
                                # subset of -S syscalls of $full_rule =&gt; existing rule can be deleted
                                # Thus delete the rule from audit.rules &amp; our array
                                sed -i -e "/$rule/d" "$audit_file"
                                existing_rules=("${existing_rules[@]//$rule/}")
                        else
                                # Rule isn't covered by $full_rule - it besides -S syscall arguments
                                # for this group contains also -S syscall arguments for other syscall
                                # group. Example: '-S lchown -S fchmod -S fchownat' =&gt; group='chown'
                                # since 'lchown' &amp; 'fchownat' share 'chown' substring
                                # Therefore:
                                # * 1) delete the original rule from audit.rules
                                # (original '-S lchown -S fchmod -S fchownat' rule would be deleted)
                                # * 2) delete the -S syscall arguments for this syscall group, but
                                # keep those not belonging to this syscall group
                                # (original '-S lchown -S fchmod -S fchownat' would become '-S fchmod'
                                # * 3) append the modified (filtered) rule again into audit.rules
                                # if the same rule not already present
                                #
                                # 1) Delete the original rule
                                sed -i -e "/$rule/d" "$audit_file"
                                # 2) Delete syscalls for this group, but keep those from other groups
                                # Convert current rule syscall's string into array splitting by '-S' delimiter
                                IFS=$'-S' read -a rule_syscalls_as_array &lt;&lt;&lt; "$rule_syscalls"
                                # Reset IFS back to default
                                unset $IFS
                                # Declare new empty string to hold '-S syscall' arguments from other groups
                                new_syscalls_for_rule=''
                                # Walk through existing '-S syscall' arguments
                                for syscall_arg in "${rule_syscalls_as_array[@]}"
                                do
                                        # Skip empty $syscall_arg values
                                        if [ "$syscall_arg" == '' ]
                                        then
                                                continue
                                        fi
                                        # If the '-S syscall' doesn't belong to current group add it to the new list
                                        # (together with adding '-S' delimiter back for each of such item found)
                                        if grep -q -v -- "$group" &lt;&lt;&lt; "$syscall_arg"
                                        then
                                                new_syscalls_for_rule="$new_syscalls_for_rule -S $syscall_arg"
                                        fi
                                done
                                # Replace original '-S syscall' list with the new one for this rule
                                updated_rule=${rule//$rule_syscalls/$new_syscalls_for_rule}
                                # Squeeze repeated whitespace characters in rule definition (if any) into one
                                updated_rule=$(echo "$updated_rule" | tr -s '[:space:]')
                                # 3) Append the modified / filtered rule again into audit.rules
                                #    (but only in case it's not present yet to prevent duplicate definitions)
                                if ! grep -q -- "$updated_rule" "$audit_file"
                                then
                                        echo "$updated_rule" &gt;&gt; "$audit_file"
                                fi
                        fi
                else
                        # $audit_file already contains the expected rule form for this
                        # architecture &amp; key =&gt; don't insert it second time
                        append_expected_rule=1
                fi
        done

        # We deleted all rules that were subset of the expected one for this arch &amp; key.
        # Also isolated rules containing system calls not from this system calls group.
        # Now append the expected rule if it's not present in $audit_file yet
        if [[ ${append_expected_rule} -eq "0" ]]
        then
                echo "$full_rule" &gt;&gt; "$audit_file"
        fi
done

}

function rhel6_perform_audit_adjtimex_settimeofday_stime_remediation {

# Perform the remediation for the 'adjtimex', 'settimeofday', and 'stime' audit
# system calls on Red Hat Enterprise Linux 6 OS
#
# Retrieve hardware architecture of the underlying system
[ $(getconf LONG_BIT) = "32" ] &amp;&amp; RULE_ARCHS=("b32") || RULE_ARCHS=("b32" "b64")

for ARCH in "${RULE_ARCHS[@]}"
do
        PATTERN="-a always,exit -F arch=${ARCH} -S .* -k *"
        # Create expected audit group and audit rule form for particular system call &amp; architecture
        if [ ${ARCH} = "b32" ]
        then
                # stime system call is known at 32-bit arch (see e.g "$ ausyscall i386 stime" 's output)
                # so append it to the list of time group system calls to be audited
                GROUP="\(adjtimex\|settimeofday\|stime\)"
                FULL_RULE="-a always,exit -F arch=${ARCH} -S adjtimex -S settimeofday -S stime -k audit_time_rules"
        elif [ ${ARCH} = "b64" ]
        then
                # stime system call isn't known at 64-bit arch (see "$ ausyscall x86_64 stime" 's output)
                # therefore don't add it to the list of time group system calls to be audited
                GROUP="\(adjtimex\|settimeofday\)"
                FULL_RULE="-a always,exit -F arch=${ARCH} -S adjtimex -S settimeofday -k audit_time_rules"
        fi
        # Perform the remediation itself
        fix_audit_syscall_rule "auditctl" "$PATTERN" "$GROUP" "$ARCH" "$FULL_RULE"
done

}
</value>
    </Value>
    <Value id="function_rhel7_fedora_perform_audit_adjtimex_settimeofday_stime_remediation" type="string" operator="equals" interactive="0" hidden="true" prohibitChanges="true">
      <title>Remediation function for the 'adjtimex', 'settimeofday', and 'stime'
audit system calls on Red Hat Enterprise Linux 7 or Fedora</title>
      <description>Perform the remediation for the 'adjtimex', 'settimeofday', and
'stime' audit system calls on Red Hat Enterprise Linux 7 or Fedora OSes</description>
      <value selector="">
function fix_audit_syscall_rule {

# Load function arguments into local variables
local tool="$1"
local pattern="$2"
local group="$3"
local arch="$4"
local full_rule="$5"

# Check sanity of the input
if [ $# -ne "5" ]
then
        echo "Usage: fix_audit_syscall_rule 'tool' 'pattern' 'group' 'arch' 'full rule'"
        echo "Aborting."
        exit 1
fi

# Create a list of audit *.rules files that should be inspected for presence and correctness
# of a particular audit rule. The scheme is as follows:
# 
# -----------------------------------------------------------------------------------------
#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |
# -----------------------------------------------------------------------------------------
#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |
# -----------------------------------------------------------------------------------------
#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |
#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |
# -----------------------------------------------------------------------------------------
#
declare -a files_to_inspect

# First check sanity of the specified audit tool
if [ "$tool" != 'auditctl' ] &amp;&amp; [ "$tool" != 'augenrules' ]
then
        echo "Unknown audit rules loading tool: $1. Aborting."
        echo "Use either 'auditctl' or 'augenrules'!"
        exit 1
# If audit tool is 'auditctl', then add '/etc/audit/audit.rules'
# file to the list of files to be inspected
elif [ "$tool" == 'auditctl' ]
then
        files_to_inspect=("${files_to_inspect[@]}" '/etc/audit/audit.rules' )
# If audit tool is 'augenrules', then check if the audit rule is defined
# If rule is defined, add '/etc/audit/rules.d/*.rules' to the list for inspection
# If rule isn't defined yet, add '/etc/audit/rules.d/$key.rules' to the list for inspection
elif [ "$tool" == 'augenrules' ]
then
        # Extract audit $key from audit rule so we can use it later
        key=$(expr "$full_rule" : '.*-k[[:space:]]\([^[:space:]]\+\)')
        # Check if particular audit rule is already defined
        IFS=$'\n' matches=($(sed -s -n -e "/${pattern}/!d" -e "/${arch}/!d" -e "/${group}/!d;F" /etc/audit/rules.d/*.rules))
        # Reset IFS back to default
        unset $IFS
        for match in "${matches[@]}"
        do
                files_to_inspect=("${files_to_inspect[@]}" "${match}")
        done
        # Case when particular rule isn't defined in /etc/audit/rules.d/*.rules yet
        if [ ${#files_to_inspect[@]} -eq "0" ]
        then
                files_to_inspect="/etc/audit/rules.d/$key.rules"
                if [ ! -e "$files_to_inspect" ]
                then
                        touch "$files_to_inspect"
                        chmod 0640 "$files_to_inspect"
                fi
        fi
fi

#
# Indicator that we want to append $full_rule into $audit_file by default
local append_expected_rule=0

for audit_file in "${files_to_inspect[@]}"
do

        # Filter existing $audit_file rules' definitions to select those that:
        # * follow the rule pattern, and
        # * meet the hardware architecture requirement, and
        # * are current syscall group specific
        IFS=$'\n' existing_rules=($(sed -e "/${pattern}/!d" -e "/${arch}/!d" -e "/${group}/!d"  "$audit_file"))
        # Reset IFS back to default
        unset $IFS

        # Process rules found case-by-case
        for rule in "${existing_rules[@]}"
        do
                # Found rule is for same arch &amp; key, but differs (e.g. in count of -S arguments)
                if [ "${rule}" != "${full_rule}" ]
                then
                        # If so, isolate just '(-S \w)+' substring of that rule
                        rule_syscalls=$(echo $rule | grep -o -P '(-S \w+ )+')
                        # Check if list of '-S syscall' arguments of that rule is subset
                        # of '-S syscall' list of expected $full_rule
                        if grep -q -- "$rule_syscalls" &lt;&lt;&lt; "$full_rule"
                        then
                                # Rule is covered (i.e. the list of -S syscalls for this rule is
                                # subset of -S syscalls of $full_rule =&gt; existing rule can be deleted
                                # Thus delete the rule from audit.rules &amp; our array
                                sed -i -e "/$rule/d" "$audit_file"
                                existing_rules=("${existing_rules[@]//$rule/}")
                        else
                                # Rule isn't covered by $full_rule - it besides -S syscall arguments
                                # for this group contains also -S syscall arguments for other syscall
                                # group. Example: '-S lchown -S fchmod -S fchownat' =&gt; group='chown'
                                # since 'lchown' &amp; 'fchownat' share 'chown' substring
                                # Therefore:
                                # * 1) delete the original rule from audit.rules
                                # (original '-S lchown -S fchmod -S fchownat' rule would be deleted)
                                # * 2) delete the -S syscall arguments for this syscall group, but
                                # keep those not belonging to this syscall group
                                # (original '-S lchown -S fchmod -S fchownat' would become '-S fchmod'
                                # * 3) append the modified (filtered) rule again into audit.rules
                                # if the same rule not already present
                                #
                                # 1) Delete the original rule
                                sed -i -e "/$rule/d" "$audit_file"
                                # 2) Delete syscalls for this group, but keep those from other groups
                                # Convert current rule syscall's string into array splitting by '-S' delimiter
                                IFS=$'-S' read -a rule_syscalls_as_array &lt;&lt;&lt; "$rule_syscalls"
                                # Reset IFS back to default
                                unset $IFS
                                # Declare new empty string to hold '-S syscall' arguments from other groups
                                new_syscalls_for_rule=''
                                # Walk through existing '-S syscall' arguments
                                for syscall_arg in "${rule_syscalls_as_array[@]}"
                                do
                                        # Skip empty $syscall_arg values
                                        if [ "$syscall_arg" == '' ]
                                        then
                                                continue
                                        fi
                                        # If the '-S syscall' doesn't belong to current group add it to the new list
                                        # (together with adding '-S' delimiter back for each of such item found)
                                        if grep -q -v -- "$group" &lt;&lt;&lt; "$syscall_arg"
                                        then
                                                new_syscalls_for_rule="$new_syscalls_for_rule -S $syscall_arg"
                                        fi
                                done
                                # Replace original '-S syscall' list with the new one for this rule
                                updated_rule=${rule//$rule_syscalls/$new_syscalls_for_rule}
                                # Squeeze repeated whitespace characters in rule definition (if any) into one
                                updated_rule=$(echo "$updated_rule" | tr -s '[:space:]')
                                # 3) Append the modified / filtered rule again into audit.rules
                                #    (but only in case it's not present yet to prevent duplicate definitions)
                                if ! grep -q -- "$updated_rule" "$audit_file"
                                then
                                        echo "$updated_rule" &gt;&gt; "$audit_file"
                                fi
                        fi
                else
                        # $audit_file already contains the expected rule form for this
                        # architecture &amp; key =&gt; don't insert it second time
                        append_expected_rule=1
                fi
        done

        # We deleted all rules that were subset of the expected one for this arch &amp; key.
        # Also isolated rules containing system calls not from this system calls group.
        # Now append the expected rule if it's not present in $audit_file yet
        if [[ ${append_expected_rule} -eq "0" ]]
        then
                echo "$full_rule" &gt;&gt; "$audit_file"
        fi
done

}

function rhel7_fedora_perform_audit_adjtimex_settimeofday_stime_remediation {

# Perform the remediation for the 'adjtimex', 'settimeofday', and 'stime' audit
# system calls on Red Hat Enterprise Linux 7 or Fedora OSes
#
# Retrieve hardware architecture of the underlying system
[ $(getconf LONG_BIT) = "32" ] &amp;&amp; RULE_ARCHS=("b32") || RULE_ARCHS=("b32" "b64")

for ARCH in "${RULE_ARCHS[@]}"
do

        PATTERN="-a always,exit -F arch=${ARCH} -S .* -k *"
        # Create expected audit group and audit rule form for particular system call &amp; architecture
        if [ ${ARCH} = "b32" ]
        then
                # stime system call is known at 32-bit arch (see e.g "$ ausyscall i386 stime" 's output)
                # so append it to the list of time group system calls to be audited
                GROUP="\(adjtimex\|settimeofday\|stime\)"
                FULL_RULE="-a always,exit -F arch=${ARCH} -S adjtimex -S settimeofday -S stime -k audit_time_rules"
        elif [ ${ARCH} = "b64" ]
        then
                # stime system call isn't known at 64-bit arch (see "$ ausyscall x86_64 stime" 's output)
                # therefore don't add it to the list of time group system calls to be audited
                GROUP="\(adjtimex\|settimeofday\)"
                FULL_RULE="-a always,exit -F arch=${ARCH} -S adjtimex -S settimeofday -k audit_time_rules"
        fi
        # Perform the remediation for both possible tools: 'auditctl' and 'augenrules'
        fix_audit_syscall_rule "auditctl" "$PATTERN" "$GROUP" "$ARCH" "$FULL_RULE"
        fix_audit_syscall_rule "augenrules" "$PATTERN" "$GROUP" "$ARCH" "$FULL_RULE"
done

}
</value>
    </Value>
    <Value id="function_replace_or_append" type="string" operator="equals" interactive="0" hidden="true" prohibitChanges="true">
      <title>Remediation function to replace configuration setting in config file or
add the configuration setting if it does not exist yet</title>
      <description>Function to replace configuration setting in config file or add
the configuration setting if it does not exist.

Expects four arguments:

  config_file:		Configuration file that will be modified
  key:			Configuration option to change
  value:		Value of the configuration option to change
  cce:			The CCE identifier or '$CCENUM' if no CCE identifier exists

Optional arguments:

  format:		Optional argument to specify the format of how key/value should be
			modified/appended in the configuration file. The default is key = value.

Example Call(s):

  With default format of 'key = value':
  replace_or_append '/etc/sysctl.conf' '^kernel.randomize_va_space' '2' '$CCENUM'

  With custom key/value format:
  replace_or_append '/etc/sysconfig/selinux' '^SELINUX=' 'disabled' '$CCENUM' '%s=%s'

  With a variable:
  replace_or_append '/etc/sysconfig/selinux' '^SELINUX=' $var_selinux_state '$CCENUM' '%s=%s'
</description>
      <value selector="">
function replace_or_append {
  local config_file=$1
  local key=$2
  local value=$3
  local cce=$4
  local format=$5

  # Check sanity of the input
  if [ $# -lt "3" ]
  then
        echo "Usage: replace_or_append 'config_file_location' 'key_to_search' 'new_value'"
        echo
        echo "If symlinks need to be taken into account, add yes/no to the last argument"
        echo "to allow to 'follow_symlinks'."
        echo "Aborting."
        exit 1
  fi

  # Test if the config_file is a symbolic link. If so, use --follow-symlinks with sed.
  # Otherwise, regular sed command will do.
  if test -L $config_file; then
    sed_command="sed -i --follow-symlinks"
  else
    sed_command="sed -i"
  fi

  # Test that the cce arg is not empty or does not equal $CCENUM.
  # If $CCENUM exists, it means that there is no CCE assigned.
  if ! [ "x$cce" = x ] &amp;&amp; [ "$cce" != '$CCENUM' ]; then
    cce="CCE-${cce}"
  else
    cce="CCE"
  fi

  # Strip any search characters in the key arg so that the key can be replaced without
  # adding any search characters to the config file.
  stripped_key=$(sed "s/[\^=\$,;+]*//g" &lt;&lt;&lt; $key)

  # If there is no print format specified in the last arg, use the default format.
  if ! [ "x$format" = x ] ; then
    printf -v formatted_output "$format" $stripped_key $value
  else
    formatted_output="$stripped_key = $value"
  fi

  # If the key exists, change it. Otherwise, add it to the config_file.
  if `grep -qi $key $config_file` ; then
    $sed_command "s/$key.*/$formatted_output/g" $config_file
  else
    # \n is precaution for case where file ends without trailing newline
    echo -e "\n# Per $cce: Set $formatted_output in $config_file" &gt;&gt; $config_file
    echo -e "$formatted_output" &gt;&gt; $config_file
  fi

}
</value>
    </Value>
    <Value id="function_firefox_js_setting" type="string" operator="equals" interactive="0" hidden="true" prohibitChanges="true">
      <title>Remediation function to replace configuration setting(s) in the Firefox
preferences JavaScript file or add the preference if it does not exist yet</title>
      <description>Function to replace configuration setting(s) in the Firefox
preferences JavaScript file or add the preference if it does not exist.

Expects three arguments:

  config_file:          Configuration file that will be modified
  key:                  Configuration option to change
  value:                Value of the configuration option to change


Example Call(s):

  Without string or variable:
  firefox_js_setting "stig_settings.js" "general.config.obscure_value" "0"

  With string:
  firefox_js_setting "stig_settings.js" "general.config.filename" "\"stig.cfg\""

  With a string variable:
  firefox_js_setting "stig_settings.js" "general.config.filename" "\"$var_config_file_name\""
</description>
      <value selector="">
function firefox_js_setting {
  local firefox_js=$1
  local key=$2
  local value=$3
  local firefox_dirs="/usr/lib/firefox /usr/lib64/firefox /usr/local/lib/firefox /usr/local/lib64/firefox"
  local firefox_pref="/defaults/pref"
  local firefox_preferences="/defaults/preferences"

  # Check sanity of input
  if [ $# -lt "3" ]
  then
        echo "Usage: firefox_js_setting 'config_javascript_file' 'key_to_search' 'new_value'"
        echo
        echo "Aborting."
        exit 1
  fi

  # Check the possible Firefox install directories
  for firefox_dir in ${firefox_dirs}; do
    # If the Firefox directory exists, then Firefox is installed
    if [ -d "${firefox_dir}" ]; then
      # Different versions of Firefox have different preferences directories, check for them and set the right one
      if [ -d "${firefox_dir}/${firefox_pref}" ] ; then
        local firefox_pref_dir="${firefox_dir}/${firefox_pref}"
      elif [ -d "${firefox_dir}/${firefox_preferences}" ] ; then
        local firefox_pref_dir="${firefox_dir}/${firefox_preferences}"
      else
        mkdir -m 755 -p "${firefox_dir}/${firefox_preferences}"
        local firefox_pref_dir="${firefox_dir}/${firefox_preferences}"
      fi

      # Make sure the Firefox .js file exists and has the appropriate permissions
      if ! [ -f "${firefox_pref_dir}/${firefox_js}" ] ; then
        touch "${firefox_pref_dir}/${firefox_js}"
        chmod 644 "${firefox_pref_dir}/${firefox_js}"
      fi

      # If the key exists, change it. Otherwise, add it to the config_file.
      if `grep -q "^pref(\"${key}\", " "${firefox_pref_dir}/${firefox_js}"` ; then
        sed -i "s/pref(\"${key}\".*/pref(\"${key}\", ${value});/g" "${firefox_pref_dir}/${firefox_js}"
      else
        echo "pref(\"${key}\", ${value});" &gt;&gt; "${firefox_pref_dir}/${firefox_js}"
      fi
    fi
  done

}
</value>
    </Value>
    <Value id="function_firefox_cfg_setting" type="string" operator="equals" interactive="0" hidden="true" prohibitChanges="true">
      <title>Remediation function to replace configuration setting(s) in the Firefox
preferences configuration (.cfg) file or add the preference if it does not exist yet</title>
      <description>Function to replace configuration setting(s) in the Firefox
preferences configuration (.cfg) file or add the preference if it does not exist.

Expects three arguments:

  config_file:          Configuration file that will be modified
  key:                  Configuration option to change
  value:                Value of the configuration option to change


Example Call(s):

  Without string or variable:
  firefox_cfg_setting "stig.cfg" "extensions.update.enabled" "false"

  With string:
  firefox_cfg_setting "stig.cfg" "security.default_personal_cert" "\"Ask Every Time\""

  With a string variable:
  firefox_cfg_setting "stig.cfg" "browser.startup.homepage\" "\"${var_default_home_page}\""
</description>
      <value selector="">
function firefox_cfg_setting {
  local firefox_cfg=$1
  local key=$2
  local value=$3
  local firefox_dirs="/usr/lib/firefox /usr/lib64/firefox /usr/local/lib/firefox /usr/local/lib64/firefox"

  # Check sanity of input
  if [ $# -lt "3" ]
  then
        echo "Usage: firefox_cfg_setting 'config_cfg_file' 'key_to_search' 'new_value'"
        echo
        echo "Aborting."
        exit 1
  fi

  # Check the possible Firefox install directories
  for firefox_dir in ${firefox_dirs}; do
    # If the Firefox directory exists, then Firefox is installed
    if [ -d "${firefox_dir}" ]; then
      # Make sure the Firefox .cfg file exists and has the appropriate permissions
      if ! [ -f "${firefox_dir}/${firefox_cfg}" ] ; then
        touch "${firefox_dir}/${firefox_cfg}"
        chmod 644 "${firefox_dir}/${firefox_cfg}"
      fi

      # If the key exists, change it. Otherwise, add it to the config_file.
      if `grep -q "^lockPref(\"${key}\", " "${firefox_dir}/${firefox_cfg}"` ; then
        sed -i "s/lockPref(\"${key}\".*/lockPref(\"${key}\", ${value});/g" "${firefox_dir}/${firefox_cfg}"
      else
        echo "lockPref(\"${key}\", ${value});" &gt;&gt; "${firefox_dir}/${firefox_cfg}"
      fi
    fi
  done
}
</value>
    </Value>
  </Group>
  <Group id="intro" prodtype="all">
    <title>Introduction</title>
    <description><!-- purpose and scope of guidance -->
The purpose of this guidance is to provide security configuration
recommendations and baselines for the <product-name-macro/> operating
system. Recommended settings for the basic operating system are provided,
as well as for many network services that the system can provide to other systems.
<!-- audience -->The guide is intended for system administrators. Readers are assumed to
possess basic system administration skills for Unix-like systems, as well
as some familiarity with the product's documentation and administration
conventions. Some instructions within this guide are complex.
All directions should be followed completely and with understanding of
their effects in order to avoid serious adverse effects on the system
and its security.
</description>
    <Group id="general-principles" prodtype="all">
      <title>General Principles</title>
      <description>
The following general principles motivate much of the advice in this
guide and should also influence any configuration decisions that are
not explicitly covered.
</description>
      <Group id="principle-encrypt-transmitted-data" prodtype="all">
        <title>Encrypt Transmitted Data Whenever Possible</title>
        <description>
Data transmitted over a network, whether wired or wireless, is susceptible
to passive monitoring. Whenever practical solutions for encrypting
such data exist, they should be applied. Even if data is expected to
be transmitted only over a local network, it should still be encrypted.
Encrypting authentication data, such as passwords, is particularly
important. Networks of <product-name-macro/> machines can and should be configured
so that no unencrypted authentication data is ever transmitted between
machines.
</description>
      </Group>
      <Group id="principle-minimize-software" prodtype="all">
        <title>Minimize Software to Minimize Vulnerability</title>
        <description>
The simplest way to avoid vulnerabilities in software is to avoid
installing that software. On <product-name-macro/>,
<os-type-macro type="rhel7,rhel6,rhel5,fedora,opensuse,suse11,suse12,osp7,eap5,fuse6,wrlinux">the RPM Package Manager (originally Red Hat
Package Manager, abbreviated RPM)</os-type-macro><os-type-macro type="debian">
the Package Manager (originally
<weblink-macro link="https://www.debian.org/doc/manuals/debian-faq/ch-pkgtools.en.html" text="apt"/>)</os-type-macro>
allows for careful management of
the set of software packages installed on a system. Installed software
contributes to system vulnerability in several ways. Packages that
include setuid programs may provide local attackers a potential path to
privilege escalation. Packages that include network services may give
this opportunity to network-based attackers. Packages that include
programs which are predictably executed by local users (e.g. after
graphical login) may provide opportunities for trojan horses or other
attack code to be run undetected. The number of software packages
installed on a system can almost always be significantly pruned to include
only the software for which there is an environmental or operational need.
</description>
      </Group>
      <Group id="principle-separate-servers" prodtype="all">
        <title>Run Different Network Services on Separate Systems</title>
        <description>
Whenever possible, a server should be dedicated to serving exactly one
network service. This limits the number of other services that can
be compromised in the event that an attacker is able to successfully
exploit a software flaw in one network service.
</description>
      </Group>
      <Group id="principle-use-security-tools" prodtype="all">
        <title>Configure Security Tools to Improve System Robustness</title>
        <description>
Several tools exist which can be effectively used to improve a system's
resistance to and detection of unknown attacks. These tools can improve
robustness against attack at the cost of relatively little configuration
effort. In particular, this guide recommends and discusses the use of
host-based firewalling, SELinux for protection against
vulnerable services, and a logging and auditing infrastructure for
detection of problems.
</description>
      </Group>
      <Group id="principle-least-privilege" prodtype="all">
        <title>Least Privilege</title>
        <description>
Grant the least privilege necessary for user accounts and software to perform tasks.
For example, <tt>sudo</tt> can be implemented to limit authorization to super user
accounts on the system only to designated personnel. Another example is to limit
logins on server systems to only those administrators who need to log into them in
order to perform administration tasks. Using SELinux also follows the principle of
least privilege: SELinux policy can confine software to perform only actions on the
system that are specifically allowed. This can be far more restrictive than the
actions permissible by the traditional Unix permissions model.
</description>
      </Group>
    </Group>
    <Group id="how-to-use" prodtype="all">
      <title>How to Use This Guide</title>
      <description>
Readers should heed the following points when using the guide.
</description>
      <Group id="intro-read-sections-completely" prodtype="all">
        <title>Read Sections Completely and in Order</title>
        <description>
Each section may build on information and recommendations discussed in
prior sections. Each section should be read and understood completely;
instructions should never be blindly applied. Relevant discussion may
occur after instructions for an action. 
</description>
      </Group>
      <Group id="intro-test-non-production" prodtype="all">
        <title>Test in Non-Production Environment</title>
        <description>
This guidance should always be tested in a non-production environment
before deployment. This test environment should simulate the setup in
which the system will be deployed as closely as possible.
</description>
      </Group>
      <Group id="intro-root-shell-assumed" prodtype="all">
        <title>Root Shell Environment Assumed</title>
        <description>
Most of the actions listed in this document are written with the
assumption that they will be executed by the root user running the
<tt>/bin/bash</tt> shell. Commands preceded with a hash mark (#)
assume that the administrator will execute the commands as root, i.e.
apply the command via <tt>sudo</tt> whenever possible, or use
<tt>su</tt> to gain root privileges if <tt>sudo</tt> cannot be
used. Commands which can be executed as a non-root user are are preceded
by a dollar sign ($) prompt.
</description>
      </Group>
      <Group id="intro-formatting-conventions" prodtype="all">
        <title>Formatting Conventions</title>
        <description>
Commands intended for shell execution, as well as configuration file text,
are featured in a <tt>monospace font</tt>. <i>Italics</i> are used
to indicate instances where the system administrator must substitute
the appropriate information into a command or configuration file.
</description>
      </Group>
      <Group id="intro-reboot-required" prodtype="all">
        <title>Reboot Required</title>
        <description>
A system reboot is implicitly required after some actions in order to
complete the reconfiguration of the system. In many cases, the changes
will not take effect until a reboot is performed. In order to ensure
that changes are applied properly and to test functionality, always
reboot the system after applying a set of recommendations from this guide.
</description>
      </Group>
    </Group>
  </Group>
  <Group id="system" prodtype="all">
    <title>System Settings</title>
    <description>Contains rules that check correct system settings.</description>
    <Group id="software" prodtype="all">
      <title>Installing and Maintaining Software</title>
      <description>The following sections contain information on
security-relevant choices during the initial operating system
installation process and the setup of software
updates.</description>
      <Group id="updating">
        <title>Updating Settings</title>
      </Group>
      <Group id="integrity">
        <title>Integrity Settings</title>
      </Group>
      <Group id="gnome">
        <title>Gnome Settings</title>
      </Group>
    </Group>
    <Group id="permissions" prodtype="all">
      <title>File Permissions and Masks</title>
      <description>Traditional Unix security relies heavily on file and
directory permissions to prevent unauthorized users from reading or
modifying files to which they should not have access. 
<br/><br/>
Several of the commands in this section search filesystems
for files or directories with certain characteristics, and are
intended to be run on every local partition on a given system.
When the variable <i>PART</i> appears in one of the commands below,
it means that the command is intended to be run repeatedly, with the
name of each local partition substituted for <i>PART</i> in turn.
<br/><br/>
The following command prints a list of all xfs partitions on the local
system, which is the default filesystem for Red Hat Enterprise Linux
7 installations:
<pre>$ mount -t xfs | awk '{print $3}'</pre>
For any systems that use a different
local filesystem type, modify this command as appropriate.
</description>
      <Group id="partitions">
        <title>Restrict Partition Mount Options</title>
        <description>
System partitions can be mounted with certain options that limit what files on those partitions can do.
These options are set in the <tt>/etc/fstab</tt> configuration file, and can be used to make certain types of malicious behavior more difficult.
</description>
        <Value id="var_removable_partition" type="string" operator="equals" interactive="0">
          <title>Removable Partition</title>
          <description>
This value is used by the checks mount_option_nodev_removable_partitions, mount_option_nodev_removable_partitions, and mount_option_nodev_removable_partitions to ensure that the correct mount options are set on partitions mounted from removable media such as CD-ROMs, USB keys, and floppy drives.
This value should be modified to reflect any removable partitions that are required on the local system.
</description>
          <value selector="dev_cdrom">/dev/cdrom</value>
        </Value>
        <Rule id="mount_option_nodev_nonroot_local_partitions">
          <title>Add nodev Option to Non-Root Local Partitions</title>
          <description>
The <tt>nodev</tt> mount option prevents files from being interpreted as character or block devices.
Legitimate character and block devices should exist only in the <tt>/dev</tt> directory on the root partition or within chroot jails built for system services.
<mount-desc-macro option="nodev" part="any non-root local partitions"/>
</description>
          <rationale>
The <tt>nodev</tt> mount option prevents files from being interpreted as character or block devices.
The only legitimate location for device files is the <tt>/dev</tt> directory located on the root partition.
The only exception to this is chroot jails, for which it is not advised to set <tt>nodev</tt> on these filesystems.
</rationale>
          <oval id="mount_option_nodev_nonroot_local_partitions"/>
          <ref nist="CM-7" cis="1.1.11"/>
        </Rule>
        <Rule id="mount_option_nodev_removable_partitions">
          <title>Add nodev Option to Removable Media Partitions</title>
          <description>
The <tt>nodev</tt> mount option prevents files from being interpreted as character or block devices.
Legitimate character and block devices should exist only in the <tt>/dev</tt> directory on the root partition or within chroot jails built for system services.
<mount-desc-macro option="nodev" part="any removable media partitions"/>
</description>
          <rationale>
The only legitimate location for device files is the <tt>/dev</tt> directory located on the root partition.
An exception to this is chroot jails, and it is not advised to set <tt>nodev</tt> on partitions which contain their root filesystems.
</rationale>
          <oval id="mount_option_nodev_removable_partitions" value="var_removable_partition"/>
          <ref nist="AC-19(a),AC-19(d),AC-19(e),CM-7,MP-2"/>
        </Rule>
        <Rule id="mount_option_noexec_removable_partitions">
          <title>Add noexec Option to Removable Media Partitions</title>
          <description>
The <tt>noexec</tt> mount option prevents the direct execution of binaries on the mounted filesystem.
Preventing the direct execution of binaries from removable media (such as a USB key) provides a defense against malicious software that may be present on such untrusted media.
<mount-desc-macro option="noexec" part="any removable media partitions"/>
</description>
          <rationale>
Allowing users to execute binaries from removable media such as USB keys exposes the system to potential compromise.
</rationale>
          <ocil clause="removable media partitions are present">
To verify that binaries cannot be directly executed from removable media, run the following command:
<pre>$ grep -v noexec /etc/fstab</pre>
The resulting output will show partitions which do not have the <tt>noexec</tt> flag.
Verify all partitions in the output are not removable media.
</ocil>
          <oval id="mount_option_noexec_removable_partitions" value="var_removable_partition"/>
          <ref nist="AC-19(a),AC-19(d),AC-19(e),CM-7,MP-2" disa="87" cis="1.1.12"/>
        </Rule>
        <!-- investigate: this is like obsoleted by gvfs/DeviceKit-based mounting now -->
        <Rule id="mount_option_nosuid_removable_partitions">
          <title>Add nosuid Option to Removable Media Partitions</title>
          <description>
The <tt>nosuid</tt> mount option prevents set-user-identifier (SUID) and set-group-identifier (SGID) permissions from taking effect.
These permissions allow users to execute binaries with the same permissions as the owner and group of the file respectively.
Users should not be allowed to introduce SUID and SGID files into the system via partitions mounted from removeable media.
<mount-desc-macro option="nosuid" part="any removable media partitions"/>
</description>
          <rationale>
The presence of SUID and SGID executables should be tightly controlled.
Allowing users to introduce SUID or SGID binaries from partitions mounted off of removable media would allow them to introduce their own highly-privileged programs.
</rationale>
          <oval id="mount_option_nosuid_removable_partitions" value="var_removable_partition"/>
        </Rule>
        <Rule id="mount_option_tmp_nodev">
          <title>Add nodev Option to /tmp</title>
          <description>
The <tt>nodev</tt> mount option can be used to prevent device files from
being created in <tt>/tmp</tt>.
Legitimate character and block devices should not exist
within temporary directories like <tt>/tmp</tt>.
<mount-desc-macro option="nodev" part="/tmp"/>
</description>
          <rationale>
The only legitimate location for device files is the <tt>/dev</tt> directory located on the root partition.
The only exception to this is chroot jails.
</rationale>
          <oval id="mount_option_tmp_nodev"/>
          <ref nist="CM-7, MP-2" cis="1.1.2"/>
        </Rule>
        <Rule id="mount_option_tmp_noexec">
          <title>Add noexec Option to /tmp</title>
          <description>
The <tt>noexec</tt> mount option can be used to prevent binaries from being executed out of <tt>/tmp</tt>.
<mount-desc-macro option="noexec" part="/tmp"/>
</description>
          <rationale>
Allowing users to execute binaries from world-writable directories such as <tt>/tmp</tt> should never be necessary in normal operation and can expose the system to potential compromise.
</rationale>
          <oval id="mount_option_tmp_noexec"/>
          <ref nist="CM-7, MP-2" cis="1.1.4"/>
        </Rule>
        <Rule id="mount_option_tmp_nosuid">
          <title>Add nosuid Option to /tmp</title>
          <description>
The <tt>nosuid</tt> mount option can be used to prevent execution of setuid programs in <tt>/tmp</tt>.
The SUID and SGID permissions should not be required in these world-writable directories.
<mount-desc-macro option="nosuid" part="/tmp"/>
</description>
          <rationale>
The presence of SUID and SGID executables should be tightly controlled.
Users should not be able to execute SUID or SGID binaries from temporary storage partitions.
</rationale>
          <oval id="mount_option_tmp_nosuid"/>
          <ref nist="CM-7, MP-2" cis="1.1.3"/>
        </Rule>
        <Rule id="mount_option_dev_shm_nodev">
          <title>Add nodev Option to /dev/shm</title>
          <description>
The <tt>nodev</tt> mount option can be used to prevent creation of device files in <tt>/dev/shm</tt>.
Legitimate character and block devices should not exist within temporary directories like <tt>/dev/shm</tt>.
<mount-desc-macro option="nodev" part="/dev/shm"/>
</description>
          <rationale>
The only legitimate location for device files is the <tt>/dev</tt> directory located on the root partition.
The only exception to this is chroot jails.
</rationale>
          <oval id="mount_option_dev_shm_nodev"/>
          <ref nist="CM-7, MP-2" cis="1.1.14"/>
        </Rule>
        <Rule id="mount_option_dev_shm_noexec">
          <title>Add noexec Option to /dev/shm</title>
          <description>
The <tt>noexec</tt> mount option can be used to prevent binaries from being executed out of <tt>/dev/shm</tt>.
It can be dangerous to allow the execution of binaries from world-writable temporary storage directories such as <tt>/dev/shm</tt>.
<mount-desc-macro option="noexec" part="/dev/shm"/>
</description>
          <rationale>
Allowing users to execute binaries from world-writable directories such as <tt>/dev/shm</tt> can expose the system to potential compromise.
</rationale>
          <oval id="mount_option_dev_shm_noexec"/>
          <ref nist="CM-7, MP-2" cis="1.1.16"/>
        </Rule>
        <Rule id="mount_option_dev_shm_nosuid">
          <title>Add nosuid Option to /dev/shm</title>
          <description>
The <tt>nosuid</tt> mount option can be used to prevent execution of setuid programs in <tt>/dev/shm</tt>.
The SUID and SGID permissions should not be required in these world-writable directories.
<mount-desc-macro option="nosuid" part="/dev/shm"/>
</description>
          <rationale>
The presence of SUID and SGID executables should be tightly controlled.
Users should not be able to execute SUID or SGID binaries from temporary storage partitions.
</rationale>
          <oval id="mount_option_dev_shm_nosuid"/>
          <ref nist="CM-7, MP-2" cis="1.1.14"/>
        </Rule>
        <Rule id="mount_option_var_tmp_bind">
          <title>Bind Mount /var/tmp To /tmp</title>
          <description>
The <tt>/var/tmp</tt> directory is a world-writable directory.
Bind-mount it to <tt>/tmp</tt> in order to consolidate temporary storage into one location protected by the same techniques as <tt>/tmp</tt>.
To do so, edit <tt>/etc/fstab</tt> and add the following line:
<pre>/tmp     /var/tmp     none     rw,nodev,noexec,nosuid,bind     0 0</pre>
See the <tt>mount(8)</tt> man page for further explanation of bind mounting.
</description>
          <rationale>
Having multiple locations for temporary storage is not required.
Unless absolutely necessary to meet requirements, the storage location <tt>/var/tmp</tt> should be bind mounted to <tt>/tmp</tt> and thus share the same protections.
</rationale>
          <oval id="mount_option_var_tmp_bind"/>
          <ref nist="CM-7" cis="1.1.6"/>
        </Rule>
      </Group>
      <Group id="mounting">
        <title>Restrict Dynamic Mounting and Unmounting of
Filesystems</title>
        <description>
Linux includes a number of facilities for the automated addition and removal of filesystems on a running system.
These facilities may be necessary in many environments, but this capability also carries some risk -- whether direct risk from allowing users to introduce arbitrary filesystems, or risk that software flaws in the automated mount facility itself could allow an attacker to compromise the system.
<br/><br/>
This command can be used to list the types of filesystems that are available to the currently executing kernel:
<pre>$ find /lib/modules/`uname -r`/kernel/fs -type f -name '*.ko'</pre>
If these filesystems are not required then they can be explicitly disabled in a configuratio file in  <tt>/etc/modprobe.d</tt>.
</description>
        <Rule id="service_autofs_disabled" severity="medium">
          <title>Disable the Automounter</title>
          <description>
The <tt>autofs</tt> daemon mounts and unmounts filesystems, such as user home directories shared via NFS, on demand.
In addition, autofs can be used to handle removable media, and the default configuration provides the cdrom device as <tt>/misc/cd</tt>.
However, this method of providing access to removable media is not common, so autofs can almost always be disabled if NFS is not in use.
Even if NFS is required, it may be possible to configure filesystem mounts statically by editing <tt>/etc/fstab</tt> rather than relying on the automounter.
<br/><br/>
<systemd-service-macro enable="false" service="autofs"/>
</description>
          <ocil>
            <systemd-check-macro enable="false" service="autofs"/>
          </ocil>
          <rationale>Disabling the automounter permits the administrator to
statically control filesystem mounting through <tt>/etc/fstab</tt>.
<br/><br/>
Additionally, automatically mounting filesystems permits easy introduction of
unknown devices, thereby facilitating malicious activity.
</rationale>
          <oval id="service_autofs_disabled"/>
        </Rule>
      </Group>
      <Group id="files">
        <title>Verify Permissions on Important Files and
Directories</title>
        <description>
Permissions for many files on a system must be set restrictively to ensure sensitive information is properly protected.
This section discusses important permission restrictions which can be verified to ensure that no harmful discrepancies have arisen.
</description>
        <Group id="permissions_important_account_files">
          <title>Verify Permissions on Files with Local Account Information and Credentials</title>
          <description>
The default restrictive permissions for files which act as important security databases such as <tt>passwd</tt>, <tt>shadow</tt>, <tt>group</tt>, and <tt>gshadow</tt> files must be maintained.
Many utilities need read access to the <tt>passwd</tt> file in order to function properly, but read access to the <tt>shadow</tt> file allows malicious attacks against system passwords, and should never be enabled.
</description>
          <Rule id="userowner_shadow_file" severity="medium">
            <title>Verify User Who Owns <tt>shadow</tt> File</title>
            <description>
              <fileowner-desc-macro file="/etc/shadow" owner="root"/>
            </description>
            <ocil>
              <fileowner-check-macro file="/etc/shadow" owner="root"/>
            </ocil>
            <rationale>
The <tt>/etc/shadow</tt> file contains the list of local system accounts and stores password hashes.
Protection of this file is critical for system security.
Failure to give ownership of this file to root provides the designated owner with access to sensitive information which could weaken the system security posture.
</rationale>
            <oval id="userowner_shadow_file"/>
            <ref nist="AC-6" disa="" pcidss="Req-8.7.c"/>
          </Rule>
          <Rule id="groupowner_shadow_file" severity="medium">
            <title>Verify Group Who Owns <tt>shadow</tt> File</title>
            <description>
              <filegroupowner-desc-macro file="/etc/shadow" group="root"/>
            </description>
            <ocil>
              <filegroupowner-check-macro file="/etc/shadow" group="root"/>
            </ocil>
            <rationale>
The <tt>/etc/shadow</tt> file stores password hashes.
Protection of this file is critical for system security.
</rationale>
            <oval id="groupowner_shadow_file"/>
            <ref nist="AC-6" disa="" pcidss="Req-8.7.c"/>
          </Rule>
          <Rule id="file_permissions_etc_shadow" severity="medium">
            <title>Verify Permissions on <tt>shadow</tt> File</title>
            <description>
              <fileperms-desc-macro file="/etc/shadow" perms="0000"/>
            </description>
            <ocil>
              <fileperms-check-macro file="/etc/shadow" perms="----------"/>
            </ocil>
            <rationale>
The <tt>/etc/shadow</tt> file contains the list of local system accounts and stores password hashes.
Protection of this file is critical for system security.
Failure to give ownership of this file to root provides the designated owner with access to sensitive information which could weaken the system security posture.
</rationale>
            <oval id="file_permissions_etc_shadow"/>
            <ref nist="AC-6" disa="" pcidss="Req-8.7.c"/>
          </Rule>
          <Rule id="file_owner_etc_group" severity="medium">
            <title>Verify User Who Owns <tt>group</tt> File</title>
            <description>
              <fileowner-desc-macro file="/etc/group" owner="root"/>
            </description>
            <ocil>
              <fileowner-check-macro file="/etc/group" owner="root"/>
            </ocil>
            <rationale>
The <tt>/etc/group</tt> file contains information regarding groups that are configured on the system.
Protection of this file is important for system security.
</rationale>
            <oval id="file_owner_etc_group"/>
            <ref nist="AC-6" pcidss="Req-8.7.c"/>
          </Rule>
          <Rule id="file_groupowner_etc_group" severity="medium">
            <title>Verify Group Who Owns <tt>group</tt> File</title>
            <description>
              <filegroupowner-desc-macro file="/etc/group" group="root"/>
            </description>
            <ocil>
              <filegroupowner-check-macro file="/etc/group" group="root"/>
            </ocil>
            <rationale>
The <tt>/etc/group</tt> file contains information regarding groups that are configured on the system.
Protection of this file is important for system security.
</rationale>
            <oval id="file_groupowner_etc_group"/>
            <ref nist="AC-6" disa="" pcidss="Req-8.7.c"/>
          </Rule>
          <Rule id="file_permissions_etc_group" severity="medium">
            <title>Verify Permissions on <tt>group</tt> File</title>
            <description>
              <fileperms-desc-macro file="/etc/group" perms="644"/>
            </description>
            <ocil>
              <fileperms-check-macro file="/etc/group" perms="-rw-r--r--"/>
            </ocil>
            <rationale>
The <tt>/etc/group</tt> file contains information regarding groups that are configured on the system.
Protection of this file is important for system security.
</rationale>
            <oval id="file_permissions_etc_group"/>
            <ref nist="AC-6" disa="" pcidss="Req-8.7.c"/>
          </Rule>
          <Rule id="file_owner_etc_gshadow" severity="medium">
            <title>Verify User Who Owns <tt>gshadow</tt> File</title>
            <description>
              <fileowner-desc-macro file="/etc/gshadow" owner="root"/>
            </description>
            <ocil>
              <fileowner-check-macro file="/etc/gshadow" owner="root"/>
            </ocil>
            <rationale>
The <tt>/etc/gshadow</tt> file contains group password hashes.
Protection of this file is critical for system security.
</rationale>
            <oval id="file_owner_etc_gshadow"/>
            <ref nist="AC-6" disa=""/>
          </Rule>
          <Rule id="file_groupowner_etc_gshadow" severity="medium">
            <title>Verify Group Who Owns <tt>gshadow</tt> File</title>
            <description>
              <filegroupowner-desc-macro file="/etc/gshadow" group="root"/>
            </description>
            <ocil>
              <filegroupowner-check-macro file="/etc/gshadow" group="root"/>
            </ocil>
            <rationale>
The <tt>/etc/gshadow</tt> file contains group password hashes.
Protection of this file is critical for system security.
</rationale>
            <oval id="file_groupowner_etc_gshadow"/>
            <ref nist="AC-6" disa=""/>
          </Rule>
          <Rule id="file_permissions_etc_gshadow" severity="medium">
            <title>Verify Permissions on <tt>gshadow</tt> File</title>
            <description>
              <fileperms-desc-macro file="/etc/gshadow" perms="0000"/>
            </description>
            <ocil>
              <fileperms-check-macro file="/etc/gshadow" perms="----------"/>
            </ocil>
            <rationale>
The <tt>/etc/gshadow</tt> file contains group password hashes.
Protection of this file is critical for system security.
</rationale>
            <oval id="file_permissions_etc_gshadow"/>
            <ref nist="AC-6" disa=""/>
          </Rule>
          <Rule id="file_owner_etc_passwd" severity="medium">
            <title>Verify User Who Owns <tt>passwd</tt> File</title>
            <description>
              <fileowner-desc-macro file="/etc/passwd" owner="root"/>
            </description>
            <ocil>
              <fileowner-check-macro file="/etc/passwd" owner="root"/>
            </ocil>
            <rationale>
The <tt>/etc/passwd</tt> file contains information about the users that are configured on the system.
Protection of this file is critical for system security.
</rationale>
            <oval id="file_owner_etc_passwd"/>
            <ref nist="AC-6" disa="" pcidss="Req-8.7.c"/>
          </Rule>
          <Rule id="file_groupowner_etc_passwd" severity="medium">
            <title>Verify Group Who Owns <tt>passwd</tt> File</title>
            <description>
              <filegroupowner-desc-macro file="/etc/passwd" group="root"/>
            </description>
            <ocil>
              <filegroupowner-check-macro file="/etc/passwd" group="root"/>
            </ocil>
            <rationale>
The <tt>/etc/passwd</tt> file contains information about the users that are configured on the system.
Protection of this file is critical for system security.
</rationale>
            <oval id="file_groupowner_etc_passwd"/>
            <ref nist="AC-6" disa="" pcidss="Req-8.7.c"/>
          </Rule>
          <Rule id="file_permissions_etc_passwd" severity="medium">
            <title>Verify Permissions on <tt>passwd</tt> File</title>
            <description>
              <fileperms-desc-macro file="/etc/passwd" perms="0644"/>
            </description>
            <ocil>
              <fileperms-check-macro file="/etc/passwd" perms="-rw-r--r--"/>
            </ocil>
            <rationale>
If the <tt>/etc/passwd</tt> file is writable by a group-owner or the world the risk of its compromise is increased.
The file contains the list of accounts on the system and associated information, and protection of this file is critical for system security.
</rationale>
            <oval id="file_permissions_etc_passwd"/>
            <ref nist="AC-6" disa="" pcidss="Req-8.7.c"/>
          </Rule>
        </Group>
        <!-- pull /var/log permissions out of rsyslog discussion section? -->
        <Group id="permissions_within_important_dirs">
          <title>Verify File Permissions Within Some Important Directories</title>
          <description>
Some directories contain files whose confidentiality or integrity is notably important and may also be susceptible to misconfiguration over time, particularly if unpackaged software is installed.
As such, an argument exists to verify that files' permissions within these directories remain configured correctly and restrictively.
</description>
          <Rule id="file_permissions_library_dirs" severity="medium">
            <title>Verify that Shared Library Files Have Restrictive Permissions</title>
            <description>
System-wide shared library files, which are linked to executables during process load time or run time, are stored in the following directories by default:
<pre>/lib
/lib64
/usr/lib
/usr/lib64
</pre>
Kernel modules, which can be added to the kernel during runtime, are stored in <tt>/lib/modules</tt>.
All files in these directories should not be group-writable or world-writable.
If any file in these directories is found to be group-writable or world-writable, correct its permission with the following command:
<pre>$ sudo chmod go-w <i>FILE</i></pre>
</description>
            <ocil clause="any of these files are group-writable or world-writable">
Shared libraries are stored in the following directories:
<pre>/lib
/lib64
/usr/lib
/usr/lib64
</pre>
To find shared libraries that are group-writable or world-writable,
run the following command for each directory <i>DIR</i> which contains shared libraries:
<pre>$ sudo find -L <i>DIR</i> -perm /022 -type f</pre>
</ocil>
            <rationale>
Files from shared library directories are loaded into the address space of processes (including privileged ones) or of the kernel itself at runtime.
Restrictive permissions are necessary to protect the integrity of the system.
</rationale>
            <ref nist="AC-6" disa=""/>
            <oval id="file_permissions_library_dirs"/>
          </Rule>
          <Rule id="file_ownership_library_dirs" severity="medium">
            <title>Verify that Shared Library Files Have Root Ownership</title>
            <description>
System-wide shared library files, which are linked to executables during process load time or run time, are stored in the following directories by default:
<pre>/lib
/lib64
/usr/lib
/usr/lib64
</pre>
Kernel modules, which can be added to the kernel during runtime, are also stored in <tt>/lib/modules</tt>.
All files in these directories should be owned by the <tt>root</tt> user.
If the directory, or any file in these directories, is found to be owned by a user other than root correct its ownership with the following command:
<pre>$ sudo chown root <i>FILE</i></pre>
</description>
            <ocil clause="any of these files are not owned by root">
Shared libraries are stored in the following directories:
<pre>/lib
/lib64
/usr/lib
/usr/lib64
</pre>
For each of these directories, run the following command to find files not
owned by root:
<pre>$ sudo find -L <i>$DIR</i> \! -user root -exec chown root {} \;</pre>
</ocil>
            <rationale>
Files from shared library directories are loaded into the address space of processes (including privileged ones) or of the kernel itself at runtime.
Proper ownership is necessary to protect the integrity of the system.
</rationale>
            <ref nist="AC-6" disa=""/>
            <oval id="file_ownership_library_dirs"/>
          </Rule>
          <Rule id="file_permissions_binary_dirs" severity="medium">
            <title>Verify that System Executables Have Restrictive Permissions</title>
            <description>
System executables are stored in the following directories by default:
<pre>/bin
/sbin
/usr/bin
/usr/libexec
/usr/local/bin
/usr/local/sbin
/usr/sbin</pre>
All files in these directories should not be group-writable or world-writable.
If any file <i>FILE</i> in these directories is found
to be group-writable or world-writable, correct its permission with the
following command:
<pre>$ sudo chmod go-w <i>FILE</i></pre>
</description>
            <ocil clause="any system executables are found to be group or world writable">
System executables are stored in the following directories by default:
<pre>/bin
/sbin
/usr/bin
/usr/libexec
/usr/local/bin
/usr/local/sbin
/usr/sbin</pre>
To find system executables that are group-writable or world-writable,
run the following command for each directory <i>DIR</i> which contains system executables:
<pre>$ sudo find -L <i>DIR</i> -perm /022 -type f</pre>
</ocil>
            <rationale>
System binaries are executed by privileged users, as well as system services, and restrictive permissions are necessary to ensure execution of these programs cannot be co-opted.
</rationale>
            <ref nist="AC-6" disa=""/>
            <oval id="file_permissions_binary_dirs"/>
          </Rule>
          <Rule id="file_ownership_binary_dirs" severity="medium">
            <title>Verify that System Executables Have Root Ownership</title>
            <description>
System executables are stored in the following directories by default:
<pre>/bin
/sbin
/usr/bin
/usr/libexec
/usr/local/bin
/usr/local/sbin
/usr/sbin</pre>
All files in these directories should be owned by the <tt>root</tt> user.
If any file <i>FILE</i> in these directories is found
to be owned by a user other than root, correct its ownership with the
following command:
<pre>$ sudo chown root <i>FILE</i></pre>
</description>
            <ocil clause="any system executables are found to not be owned by root">
System executables are stored in the following directories by default:
<pre>/bin
/sbin
/usr/bin
/usr/libexec
/usr/local/bin
/usr/local/sbin
/usr/sbin</pre>
To find system executables that are not owned by <tt>root</tt>,
run the following command for each directory <i>DIR</i> which contains system executables:
<pre>$ sudo find <i>DIR/</i> \! -user root</pre>
</ocil>
            <rationale>
System binaries are executed by privileged users as well as system services, and restrictive permissions are necessary to ensure that their execution of these programs cannot be co-opted.
</rationale>
            <oval id="file_ownership_binary_dirs"/>
            <ref nist="AC-6" disa=""/>
          </Rule>
        </Group>
        <Rule id="dir_perms_world_writable_sticky_bits">
          <title>Verify that All World-Writable Directories Have Sticky Bits Set</title>
          <description>
When the so-called 'sticky bit' is set on a directory, only the owner of a given file may remove that file from the directory.
Without the sticky bit, any user with write access to a directory may remove any file in the directory.
Setting the sticky bit prevents users from removing each other's files.
In cases where there is no reason for a directory to be world-writable, a better solution is to remove that permission rather than to set the sticky bit.
However, if a directory is used by a particular application, consult that application's documentation instead of blindly changing modes.
<br/>
To set the sticky bit on a world-writable directory <i>DIR</i>, run the following command:
<pre>$ sudo chmod +t <i>DIR</i></pre>
</description>
          <ocil clause="any world-writable directories are missing the sticky bit">
To find world-writable directories that lack the sticky bit, run the following command:
<pre>$ sudo find / -xdev -type d -perm 002 ! -perm 1000</pre>
</ocil>
          <rationale>
Failing to set the sticky bit on public directories allows unauthorized users to delete files in the directory structure.
<br/><br/>
The only authorized public directories are those temporary directories supplied with the system, or those designed to be temporary file repositories.
The setting is normally reserved for directories used by the system, by users for temporary file storage (such as <tt>/tmp</tt>), and for directories requiring global read/write access.
</rationale>
          <oval id="dir_perms_world_writable_sticky_bits"/>
          <ref nist="AC-6" cis="1.1.17"/>
        </Rule>
        <Rule id="file_permissions_unauthorized_world_writable" severity="medium">
          <title>Ensure No World-Writable Files Exist</title>
          <description>
It is generally a good idea to remove global (other) write access to a file when it is discovered.
However, check with documentation for specific applications before making changes.
Also, monitor for recurring world-writable files, as these may be symptoms of a misconfigured application or user account.
</description>
          <ocil clause="there is output">
To find world-writable files, run the following command:
<pre>$ sudo find / -xdev -type f -perm -002</pre>
</ocil>
          <rationale>
Data in world-writable files can be modified by any user on the system.
In almost all circumstances, files can be configured using a combination of user and group permissions to support whatever legitimate access is needed without the risk caused by world-writable files.
</rationale>
          <ref nist="AC-6"/>
          <oval id="file_permissions_unauthorized_world_writable"/>
        </Rule>
        <Rule id="file_permissions_unauthorized_sgid">
          <title>Ensure All SGID Executables Are Authorized</title>
          <description>
The SGID (set group id) bit should be set only on files that were installed via authorized means.
A straightforward means of identifying unauthorized SGID files is determine if any were not installed as part of an RPM package, which is cryptographically verified.
Investigate the origin of any unpackaged SGID files.
</description>
          <ocil clause="there is output">
To find world-writable files, run the following command:
<pre>$ sudo find / -xdev -type f -perm -002</pre>
</ocil>
          <rationale>
Executable files with the SGID permission run with the privileges of the owner of the file.
SGID files of uncertain provenance could allow for unprivileged users to elevate privileges.
The presence of these files should be strictly controlled on the system.
</rationale>
          <oval id="file_permissions_unauthorized_sgid"/>
          <ref nist="AC-6(1)"/>
        </Rule>
        <Rule id="file_permissions_unauthorized_suid">
          <title>Ensure All SUID Executables Are Authorized</title>
          <description>
The SUID (set user id) bit should be set only on files that were installed via authorized means.
A straightforward means of identifying unauthorized SGID files is determine if any were not installed as part of an RPM package, which is cryptographically verified.
Investigate the origin of any unpackaged SUID files.
</description>
          <ocil>
To find world-writable files, run the following command:
<pre>$ sudo find / -xdev -type f -perm -002</pre>
</ocil>
          <rationale>
Executable files with the SUID permission run with the privileges of the owner of the file.
SUID files of uncertain provenance could allow for unprivileged users to elevate privileges.
The presence of these files should be strictly controlled on the system.
</rationale>
          <oval id="file_permissions_unauthorized_suid"/>
          <ref nist="AC-6(1)"/>
        </Rule>
        <Rule id="no_files_unowned_by_user" severity="medium">
          <title>Ensure All Files Are Owned by a User</title>
          <description>
If any files are not owned by a user, then the cause of their lack of ownership should be investigated.
Following this, the files should be deleted or assigned to an appropriate user.
</description>
          <ocil clause="files exist that are not owned by a valid user">
The following command will discover and print any
files on local partitions which do not belong to a valid user.
<pre>$ sudo find / -xdev -fstype local -nouser</pre>
<br/><br/>
Either remove all files and directories from the system that do not have a
valid user, or assign a valid user to all unowned files and directories on
the system with the <tt>chown</tt> command:
<pre>$ sudo chown <tt>user</tt> <tt>file</tt></pre>
</ocil>
          <rationale>
Unowned files do not directly imply a security problem, but they are generally a sign that something is amiss.
They may be caused by an intruder, by incorrect software installation or draft software removal, or by failure to remove all files belonging to a deleted account.
The files should be repaired so they will not cause problems when accounts are created in the future, and the cause should be discovered and addressed.
</rationale>
          <oval id="no_files_unowned_by_user"/>
        </Rule>
        <Rule id="file_permissions_ungroupowned" severity="medium">
          <title>Ensure All Files Are Owned by a Group</title>
          <description>
If any files are not owned by a group, then the cause of their lack of group-ownership should be investigated.
Following this, the files should be deleted or assigned to an appropriate group.
</description>
          <ocil clause="there is output">
The following command will discover and print any
files on local partitions which do not belong to a valid group.
<pre>$ sudo find / -xdev -fstype local -nogroup</pre>
<br/>
Either remove all files and directories from the system that do not have a valid group,
or assign a valid group with the chgrp command:
<pre>$ sudo chgrp <i>group</i> <i>file</i></pre>
</ocil>
          <rationale>
Unowned files do not directly imply a security problem, but they are generally a sign that something is amiss.
They may be caused by an intruder, by incorrect software installation or draft software removal, or by failure to remove all files belonging to a deleted account.
The files should be repaired so they will not cause problems when accounts are created in the future, and the cause should be discovered and addressed.
</rationale>
          <oval id="file_permissions_ungroupowned"/>
        </Rule>
        <Rule id="dir_perms_world_writable_system_owned">
          <title>Ensure All World-Writable Directories Are Owned by a System Account</title>
          <description>
All directories in local partitions which are world-writable should be owned by root or another system account.
If any world-writable directories are not owned by a system account, this should be investigated.
Following this, the files should be deleted or assigned to an appropriate group.
</description>
          <ocil clause="there is output">
The following command will discover and print world-writable directories that are not owned by a system account, given the assumption that only system accounts have a uid lower than 500.
Run it once for each local partition <i>PART</i>: <pre>$ sudo find <i>PART</i> -xdev -type d -perm -0002 -uid +499 -print</pre>
</ocil>
          <rationale>
Allowing a user account to own a world-writable directory is undesirable because it allows the owner of that directory to remove or replace any files that may be placed in the directory by other users.
</rationale>
          <oval id="dir_perms_world_writable_system_owned"/>
        </Rule>
      </Group>
      <Group id="execution">
        <title>Execution Settings</title>
      </Group>
    </Group>
    <Group id="selinux">
      <title>SE Linux Settings</title>
      <Value id="var_selinux_policy_name" type="string" operator="equals" interactive="0">
        <title>SELinux policy</title>
        <description>
Type of policy in use. Possible values are:
<br/>targeted - Only targeted network daemons are protected.
<br/>strict - Full SELinux protection.
<br/>mls - Multiple levels of security
</description>
        <value selector="">targeted</value>
        <value selector="targeted">targeted</value>
        <value selector="mls">mls</value>
      </Value>
    </Group>
    <Group id="accounts" prodtype="all">
      <title>Account and Access Control</title>
      <description>In traditional Unix security, if an attacker gains
shell access to a certain login account, they can perform any action
or access any file to which that account has access. Therefore,
making it more difficult for unauthorized people to gain shell
access to accounts, particularly to privileged accounts, is a
necessary part of securing a system. This section introduces
mechanisms for restricting access to accounts under
<product-name-macro/>.</description>
      <Group id="accounts-restrictions" prodtype="all">
        <title>Protect Accounts by Restricting Password-Based Login</title>
        <description>Conventionally, Unix shell accounts are accessed by
providing a username and password to a login program, which tests
these values for correctness using the <tt>/etc/passwd</tt> and
<tt>/etc/shadow</tt> files. Password-based login is vulnerable to
guessing of weak passwords, and to sniffing and man-in-the-middle
attacks against passwords entered over a network or at an insecure
console. Therefore, mechanisms for accessing accounts by entering
usernames and passwords should be restricted to those which are
operationally necessary.</description>
        <Group id="root_logins">
          <title>Restrict Root Logins</title>
          <description>
Direct root logins should be allowed only for emergency use.
In normal situations, the administrator should access the system via a unique unprivileged account, and then use <tt>su</tt> or <tt>sudo</tt> to execute privileged commands.
Discouraging administrators from accessing the root account directly ensures an audit trail in organizations with multiple administrators.
Locking down the channels through which root can connect directly also reduces opportunities for password-guessing against the root account.
The <tt>login</tt> program uses the file <tt>/etc/securetty</tt> to determine which interfaces should allow root logins.
<br/>
The virtual devices <tt>/dev/console</tt> and <tt>/dev/tty*</tt> represent the system consoles (accessible via the Ctrl-Alt-F1 through Ctrl-Alt-F6 keyboard sequences on a default installation).
The default securetty file also contains <tt>/dev/vc/*</tt>.
These are likely to be deprecated in most environments, but may be retained for compatibility.
Furthermore, <tt>/dev/hvc*</tt> represent virtio-serial consoles, <tt>/dev/hvsi*</tt> IBM pSeries serial consoles, and finally <tt>/dev/xvc0</tt> Xen virtual console.
Root should also be prohibited from connecting via network protocols.
Other sections of this document include guidance describing how to prevent root from logging in via SSH.
</description>
          <Rule id="no_direct_root_logins" severity="medium">
            <title>Direct root Logins Not Allowed</title>
            <description>
To further limit access to the <tt>root</tt> account, administrators can disable root logins at the console by editing the <tt>/etc/securetty</tt> file.
This file lists all devices the root user is allowed to login to.
If the file does not exist at all, the root user can login through any communication device on the system, whether via the console or via a raw network interface.
This is dangerous as user can login to his machine as root via Telnet, which sends the password in plain text over the network.
By default, WRLinux's <tt>/etc/securetty</tt> file only allows the root user to login at the console physically attached to the machine.
To prevent root from logging in, remove the contents of this file.
To prevent direct root logins, remove the contents of this file by typing the following command:
<pre>echo &gt; /etc/securetty</pre>
</description>
            <ocil clause="the /etc/securetty file is not empty">
To ensure root may not directly login to the system over physical consoles, run the following command:
<pre>cat /etc/securetty</pre>
If any output is returned, this is a finding.
</ocil>
            <rationale>
Disabling direct root logins ensures proper accountability and multifactor authentication to privileged accounts.
Users will first login, then escalate to privileged (root) access via su / sudo.
This scenario is nowadays required by security standards.
</rationale>
            <oval id="no_direct_root_logins"/>
            <ref nist="IA-2(1)"/>
          </Rule>
          <Rule id="accounts_no_uid_except_zero" severity="high">
            <title>Only Root Has UID 0</title>
            <description>
If any account other than root has a UID of 0, this misconfiguration should be investigated and the accounts other than root should be removed or have their UID changed.
</description>
            <ocil clause="any account other than root has a UID of 0">
To list all password file entries for accounts with UID 0, run the following command:
<pre># awk -F: '($3 == "0") {print}' /etc/passwd</pre>
This should print only one line, for the user root.
</ocil>
            <rationale>
An account has root authority if it has a UID of 0.
Multiple accounts with a UID of 0 afford greater opportunity for potential intruders to guess or decrypt the password for a privileged account.
Proper configuration of sudo is recommended to afford multiple system administrators access to root privileges in an accountable manner.
</rationale>
            <oval id="accounts_no_uid_except_zero"/>
            <ref nist="AC-6,IA-2(1)" disa="366"/>
          </Rule>
        </Group>
        <Group id="password_storage">
          <title>Proper Storage and Existence of Password Hashes</title>
          <description>
By default, password hashes for local accounts are stored in the second field (colon-separated) in <tt>/etc/shadow</tt>.
This file should be readable only by processes running with root credentials, preventing users from casually accessing others' password hashes and attempting to crack them.
However, it remains possible to misconfigure the system and store password hashes in world-readable files such as <tt>/etc/passwd</tt>, or to even store passwords themselves in plaintext on the system.
Using system-provided tools for password change/creation should allow administrators to avoid such misconfiguration.
</description>
          <Rule id="no_empty_passwords" severity="high">
            <title>Log In to Accounts With Empty Password Impossible</title>
            <description>
If an account is configured for password authentication but does not have an assigned password, it may be possible to log into the account without authentication.
Remove any instances of the <tt>nullok</tt> option in <tt>/etc/pam.d/system-auth</tt> to prevent logins with empty passwords.
</description>
            <ocil clause="NULL passwords can be used">
To verify that null passwords cannot be used, run the following command:
<pre># grep nullok /etc/pam.d/common-auth</pre>
If this produces any output, it may be possible to log into accounts with empty passwords.
</ocil>
            <rationale>
If an account has an empty password, anyone could log in and run commands with the privileges of that account.
Accounts with empty passwords should never be used in operational environments.
<br/>
Note that if the output includes <tt>nullok-secure</tt> but not <tt>nullok</tt>, then the vulnerability is limited to the specified set of terminals listed in <tt>/etc/securetty</tt>.
</rationale>
            <oval id="no_empty_passwords"/>
            <ref nist="IA-5(b),IA-5(c),IA-5(1)(a)"/>
          </Rule>
          <Rule id="accounts_password_all_shadowed" severity="medium">
            <title>Password Hashes For Each Account Shadowed</title>
            <description>
If any password hashes are stored in <tt>/etc/passwd</tt> (in the second field, instead of an <tt>x</tt>), the cause of this misconfiguration should be investigated.
Every affected account should have its password reset and the hash should be properly stored, or the account should be deleted entirely.
</description>
            <ocil clause="any stored hashes are found in /etc/passwd">
To check that no password hashes are stored in <tt>/etc/passwd</tt>, run the following command:
<pre># awk -F: '($2 != "x") {print}' /etc/passwd</pre>
If it produces any output, then a password hash is stored in <tt>/etc/passwd</tt>.
</ocil>
            <rationale>
The hashes for all user account passwords should be stored in the file <tt>/etc/shadow</tt> and never in <tt>/etc/passwd</tt>, which is readable by all users.
</rationale>
            <oval id="accounts_password_all_shadowed"/>
            <ref nist="IA-5(h)" disa="201"/>
          </Rule>
          <Rule id="no_netrc_files" severity="medium">
            <title>netrc Files Do Not Exist</title>
            <description>
The <tt>.netrc</tt> files contain login information used to auto-login into FTP servers and reside in the user's home directory.
These files may contain unencrypted passwords to remote FTP servers making them susceptible to access by unauthorized users and should not be used.
Any <tt>.netrc</tt> files should be removed.
</description>
            <ocil clause="any .netrc files exist">
To check the system for the existence of any <tt>.netrc</tt> files, run the following command:
<!-- limit the search to home directories -->
<pre># find `cut -d : -f 6 /etc/passwd` -xdev -name .netrc 2&gt;/dev/null</pre>
</ocil>
            <rationale>
Unencrypted passwords for remote FTP servers may be stored in <tt>.netrc</tt> files.
DoD policy requires passwords be encrypted in storage and not used in access scripts.
</rationale>
            <oval id="no_netrc_files"/>
            <ref nist="IA-5(h)" disa="196"/>
          </Rule>
        </Group>
        <Group id="password_expiration">
          <title>Set Password Expiration Parameters</title>
          <description>
The file <tt>/etc/login.defs</tt> controls several password-related settings.
Programs such as <tt>passwd</tt>, <tt>su</tt>, and <tt>login</tt> consult <tt>/etc/login.defs</tt> to determine behavior with regard to password aging, expiration warnings, and length.
See the man page <tt>login.defs(5)</tt> for more information.
<br/><br/>
Users should be forced to change their passwords, in order to decrease the utility of compromised passwords.
However, the need to change passwords often should be balanced against the risk that users will reuse or write down passwords if forced to change them too often.
Forcing password changes every 90-360 days, depending on the environment, is recommended.
Set the appropriate value as <tt>PASS_MAX_DAYS</tt> and apply it to existing accounts with the <tt>-M</tt> flag.
<br/><br/>
The <tt>PASS_MIN_DAYS</tt> (<tt>-m</tt>) setting prevents password changes for 7 days after the first change, to discourage password cycling.
If you use this setting, train users to contact an administrator for an emergency password change in case a new password becomes compromised.
The <tt>PASS_WARN_AGE</tt> (<tt>-W</tt>) setting gives users 7 days of warnings at login time that their passwords are about to expire.
<br/><br/>
For example, for each existing human user <i>USER</i>, expiration parameters could be adjusted to a 180 day maximum password age, 7 day minimum password age, and 7 day warning period with the following command:
<pre># chage -M 180 -m 7 -W 7 USER</pre>
</description>
          <Value id="var_accounts_password_warn_age_login_defs" type="number">
            <title>warning days before password expires</title>
            <description>
The number of days' warning given before a password expires.</description>
            <warning category="general">This will only apply to newly created accounts</warning>
            <value selector="">7</value>
            <value selector="0">0</value>
            <value selector="7">7</value>
            <value selector="14">14</value>
          </Value>
          <Rule id="accounts_password_warn_age_login_defs">
            <title>Password Warning Age</title>
            <description>
To specify how many days prior to password expiration that a warning will be issued to users, edit the file <tt>/etc/login.defs</tt>, locate the following line:
<pre>PASS_WARN_AGE <b>DAYS</b></pre>
and correct it to have the form of:
<pre>PASS_WARN_AGE <b><sub idref="var_accounts_password_warn_age_login_defs"/></b></pre>
<br/>
A value of 7 days would be nowadays considered to be a standard.
</description>
            <ocil clause="it is not set to the required value">
To check the password warning age, run the command:
<pre>$ grep PASS_WARN_AGE /etc/login.defs</pre>
A value of 7 days would be nowadays considered to be a standard.
</ocil>
            <rationale>
Setting the password warning age enables users to make the change at a practical time.
</rationale>
            <oval id="accounts_password_warn_age_login_defs" value="var_accounts_password_warn_age_login_defs"/>
            <ref nist="IA-5(f)"/>
          </Rule>
        </Group>
        <Group id="account_expiration">
          <title>Account expiration Settings</title>
        </Group>
      </Group>
      <Group id="pam">
        <title>pam Settings</title>
        <Value id="var_accounts_passwords_pam_faillock_deny" type="number" operator="equals" interactive="0">
          <title>fail_deny</title>
          <description>Number of failed login attempts before account lockout</description>
          <value selector="">3</value>
          <value selector="3">3</value>
          <value selector="5">5</value>
          <value selector="6">6</value>
          <value selector="10">10</value>
        </Value>
        <Value id="var_accounts_passwords_pam_faillock_unlock_time" type="number" operator="equals" interactive="0">
          <title>fail_unlock_time</title>
          <description>Seconds before automatic unlocking after excessive failed logins</description>
          <value selector="">604800</value>
          <value selector="600">600</value>
          <!-- 10 minutes -->
          <value selector="900">900</value>
          <!-- 15 minutes -->
          <value selector="1800">1800</value>
          <!-- 30 minutes -->
          <value selector="3600">3600</value>
          <!-- 1 hour -->
          <value selector="86400">86400</value>
          <!-- 1 day -->
          <value selector="604800">604800</value>
          <!-- 7 days -->
        </Value>
      </Group>
      <Group id="accounts-session">
        <title>Secure Session Configuration Files for Login Accounts</title>
        <description>
When a user logs into a Unix account, the system configures the user's session by reading a number of files.
Many of these files are located in the user's home directory, and may have weak permissions as a result of user error or misconfiguration.
If an attacker can modify or even read certain types of account configuration information, they can often gain full access to the affected user's account.
Therefore, it is important to test and correct configuration file permissions for interactive accounts, particularly those of privileged users such as root or system administrators.
</description>
        <Value id="var_accounts_max_concurrent_login_sessions" type="number" operator="equals" interactive="0">
          <title>Maximum concurrent login sessions</title>
          <description>Maximum number of concurrent sessions by a user</description>
          <value selector="">1</value>
          <value selector="1">1</value>
          <value selector="3">3</value>
          <value selector="5">5</value>
          <value selector="10">10</value>
          <value selector="15">15</value>
          <value selector="20">20</value>
        </Value>
        <Value id="var_accounts_fail_delay" type="number" operator="equals" interactive="0">
          <title>Maximum login attempts delay</title>
          <description>Maximum time in seconds between fail login attempts before re-prompting.</description>
          <value selector="">4</value>
          <value selector="1">1</value>
          <value selector="2">2</value>
          <value selector="3">3</value>
          <value selector="4">4</value>
          <value selector="5">5</value>
        </Value>
        <Rule id="accounts_max_concurrent_login_sessions" severity="low">
          <title>Limit the Number of Concurrent Login Sessions Allowed Per User</title>
          <description>
Limiting the number of allowed users and sessions per user can limit risks related to Denial of Service attacks.
This addresses concurrent sessions for a single account and does not address concurrent sessions by a single user via multiple accounts.
To set the number of concurrent sessions per user add the following line in <tt>/etc/security/limits.conf</tt>:
<pre>* hard maxlogins <sub idref="var_accounts_max_concurrent_login_sessions"/></pre>
</description>
          <rationale>
Limiting simultaneous user logins can insulate the system from denial of service problems caused by excessive logins.
Automated login processes operating improperly or maliciously may result in an exceptional number of simultaneous login sessions.
</rationale>
          <ocil clause="maxlogins is not equal to or less than the expected value">
Run the following command to ensure the <tt>maxlogins</tt> value is configured for all users on the system:
<pre># grep "maxlogins" /etc/security/limits.conf</pre>
You should receive output similar to the following:
<pre>*          hard    maxlogins       <sub idref="var_accounts_max_concurrent_login_sessions"/></pre>
</ocil>
          <oval id="accounts_max_concurrent_login_sessions" value="var_accounts_max_concurrent_login_sessions"/>
        </Rule>
        <Rule id="accounts_logon_fail_delay">
          <title>Ensure the Logon Failure Delay is Set Correctly in login.defs</title>
          <description>
To ensure the logon failure delay controlled by <tt>/etc/login.defs</tt> is set properly, add or correct the <tt>FAIL_DELAY</tt> setting in <tt>/etc/login.defs</tt> to read as follows:
<pre>FAIL_DELAY <sub idref="var_accounts_fail_delay"/></pre>
</description>
          <ocil clause="the above command returns no output, or FAIL_DELAY is configured less than the expected value">
Verify the <tt>FAIL_DELAY</tt> setting is configured correctly in the <tt>/etc/login.defs</tt> file by running the following command:
<pre>$ sudo grep -i "FAIL_DELAY" /etc/login.defs</pre>
All output must show the value of <tt>FAIL_DELAY</tt> set as shown in the below:
<pre>$ sudo grep -i "FAIL_DELAY" /etc/login.defs
fail_delay <sub idref="var_accounts_fail_delay"/></pre>
</ocil>
          <rationale>
Increasing the time between a failed authentication attempt and re-prompting to enter credentials helps to slow a single-threaded brute force attack.
</rationale>
          <oval id="accounts_logon_fail_delay" value="var_accounts_fail_delay"/>
        </Rule>
        <Group id="root_paths">
          <title>Ensure that No Dangerous Directories Exist in Root's Path</title>
          <description>
The active path of the root account can be obtained by starting a new root shell and running:
<pre>$ sudo echo $PATH</pre>
This will produce a colon-separated list of directories in the path.
<br/><br/>
Certain path elements could be considered dangerous, as they could lead to root executing unknown or untrusted programs, which could contain malicious code.
Since root may sometimes work inside untrusted directories, the <tt>.</tt> character, which represents the current directory, should never be in the root path, nor should any directory which can be written to by an unprivileged or semi-privileged (system) user.
<br/><br/>
It is a good practice for administrators to always execute privileged commands by typing the full path to the command.
</description>
          <Rule id="root_path_no_dot">
            <title>Ensure that Root's Path Does Not Include Relative Paths or Null Directories</title>
            <description>
Ensure that none of the directories in root's path is equal to a single
<tt>.</tt> character, or
that it contains any instances that lead to relative path traversal, such as
<tt>..</tt> or beginning a path without the slash (<tt>/</tt>) character.
Also ensure that there are no "empty" elements in the path, such as in these examples:
<pre>PATH=:/bin
PATH=/bin:
PATH=/bin::/sbin</pre>
These empty elements have the same effect as a single <tt>.</tt> character.
</description>
            <rationale>
Including these entries increases the risk that root could
execute code from an untrusted location.
</rationale>
            <oval id="root_path_no_dot"/>
            <ref nist="CM-6(b)" disa="366"/>
          </Rule>
          <Rule id="accounts_root_path_dirs_no_write">
            <title>Ensure that Root's Path Does Not Include World or Group-Writable Directories</title>
            <description>
For each element in root's path, run:
<pre>$ sudo ls -ld <i>DIR</i></pre>
and ensure that write permissions are disabled for group and other.
</description>
            <ocil clause="group or other write permissions exist">
To ensure write permissions are disabled for group and other for each element in root's path, run the following command:
<pre>$ sudo ls -ld <i>DIR</i></pre>
</ocil>
            <rationale>
Such entries increase the risk that root could execute code provided by unprivileged users, and potentially malicious code.
</rationale>
            <oval id="accounts_root_path_dirs_no_write"/>
            <ref nist="CM-6(b)" disa="366"/>
          </Rule>
        </Group>
        <Rule id="file_permissions_home_dirs">
          <title>Ensure that User Home Directories are not Group-Writable or World-Readable</title>
          <description>
For each human user of the system, view the permissions of the user's home directory:
<pre>$ sudo ls -ld /home/<i>USER</i></pre>
Ensure that the directory is not group-writable and that it is not world-readable.
If necessary, repair the permissions:
<pre>$ sudo chmod g-w /home/<i>USER</i>
$ sudo chmod o-rwx /home/<i>USER</i></pre>
</description>
          <ocil clause="the user home directory is group-writable or world-readable">
To ensure the user home directory is not group-writable or world-readable, run the following:
<pre>$ sudo ls -ld /home/<i>USER</i></pre>
</ocil>
          <warning category="general">
This action may involve modifying user home directories.
Notify your user community, and solicit input if appropriate, before making this type of change.
</warning>
          <rationale>
User home directories contain many configuration files which affect the behavior of a user's account.
No user should ever have write permission to another user's home directory.
Group shared directories can be configured in sub-directories or elsewhere in the filesystem if they are needed.
Typically, user home directories should not be world-readable, as it would disclose file names to other users.
If a subset of users need read access to one another's home directories, this can be provided using groups or ACLs.
</rationale>
          <oval id="file_permissions_home_dirs"/>
          <ref nist="AC-6(7)" disa="225"/>
        </Rule>
        <Group id="user_umask">
          <title>Ensure that Users Have Sensible Umask Values</title>
          <description>
The umask setting controls the default permissions for the creation of new files.
With a default <tt>umask</tt> setting of 077, files and directories created by users will not be readable by any other user on the system.
Users who wish to make specific files group- or world-readable can accomplish this by using the chmod command.
Additionally, users can make all their files readable to their group by default by setting a <tt>umask</tt> of 027 in their shell configuration files.
If default per-user groups exist (that is, if every user has a default group whose name is the same as that user's username and whose only member is the user), then it may even be safe for users to select a <tt>umask</tt> of 007, making it very easy to intentionally share files with groups of which the user is a member.
<br/><br/>
</description>
          <Value id="var_accounts_user_umask" type="string" operator="equals" interactive="0">
            <title>Sensible umask</title>
            <description>Enter default user umask</description>
            <value selector="">077</value>
            <value selector="007">007</value>
            <value selector="022">022</value>
            <value selector="027">027</value>
            <value selector="077">077</value>
          </Value>
          <Rule id="accounts_umask_etc_bashrc">
            <title>Ensure the Default Bash Umask is Set Correctly</title>
            <description>
To ensure the default umask for users of the Bash shell is set properly,
add or correct the <tt>umask</tt> setting in <tt>/etc/bashrc</tt> to read
as follows:
<pre>umask <sub idref="var_accounts_user_umask"/></pre>
</description>
            <rationale>
The umask value influences the permissions assigned to files when they are created.
A misconfigured umask value could result in files with excessive permissions that can be read or written to by unauthorized users.
</rationale>
            <ocil clause="the above command returns no output, or if the umask is configured incorrectly">
Verify the <tt>umask</tt> setting is configured correctly in the <tt>/etc/bashrc</tt> file by running the following command:
<pre># grep "umask" /etc/bashrc</pre>
All output must show the value of <tt>umask</tt> set as shown below:
<pre># grep "umask" /etc/bashrc
umask <sub idref="var_accounts_user_umask"/>
umask <sub idref="var_accounts_user_umask"/></pre>
</ocil>
            <oval id="accounts_umask_etc_bashrc" value="var_accounts_user_umask"/>
            <ref nist="SA-8" disa="366"/>
          </Rule>
          <Rule id="accounts_umask_etc_csh_cshrc">
            <title>Ensure the Default C Shell Umask is Set Correctly</title>
            <description>
To ensure the default umask for users of the C shell is set properly,
add or correct the <tt>umask</tt> setting in <tt>/etc/csh.cshrc</tt> to read as follows:
<pre>umask <sub idref="var_accounts_user_umask"/></pre>
</description>
            <rationale>
The umask value influences the permissions assigned to files when they are created.
A misconfigured umask value could result in files with excessive permissions that can be read or written to by unauthorized users.
</rationale>
            <ocil clause="the above command returns no output, or if the umask is configured incorrectly">
Verify the <tt>umask</tt> setting is configured correctly in the <tt>/etc/csh.cshrc</tt> file by
running the following command:
<pre># grep "umask" /etc/csh.cshrc</pre>
All output must show the value of <tt>umask</tt> set as shown in the below:
<pre># grep "umask" /etc/csh.cshrc
umask <sub idref="var_accounts_user_umask"/></pre>
</ocil>
            <oval id="accounts_umask_etc_csh_cshrc" value="var_accounts_user_umask"/>
            <ref nist="SA-8" disa="366"/>
          </Rule>
          <Rule id="accounts_umask_etc_profile">
            <title>Ensure the Default Umask is Set Correctly in /etc/profile</title>
            <description>
To ensure the default umask controlled by <tt>/etc/profile</tt> is set properly, add or correct the <tt>umask</tt> setting in <tt>/etc/profile</tt> to read as follows:
<pre>umask <sub idref="var_accounts_user_umask"/></pre>
</description>
            <rationale>
The umask value influences the permissions assigned to files when they are created.
A misconfigured umask value could result in files with excessive permissions that can be read or written to by unauthorized users.
</rationale>
            <ocil clause="the above command returns no output, or if the umask is configured incorrectly">
Verify the <tt>umask</tt> setting is configured correctly in the <tt>/etc/profile</tt> file by
running the following command:
<pre># grep "umask" /etc/profile</pre>
All output must show the value of <tt>umask</tt> set as shown in the below:
<pre># grep "umask" /etc/profile
umask <sub idref="var_accounts_user_umask"/></pre>
</ocil>
            <oval id="accounts_umask_etc_profile" value="var_accounts_user_umask"/>
            <ref nist="SA-8" disa="366"/>
          </Rule>
          <Rule id="accounts_umask_etc_login_defs">
            <title>Ensure the Default Umask is Set Correctly in login.defs</title>
            <description>
To ensure the default umask controlled by <tt>/etc/login.defs</tt> is set properly, add or correct the <tt>UMASK</tt> setting in <tt>/etc/login.defs</tt> to read as follows:
<pre>UMASK <sub idref="var_accounts_user_umask"/></pre>
</description>
            <rationale>
The umask value influences the permissions assigned to files when they are created.
A misconfigured umask value could result in files with excessive permissions that can be read and written to by unauthorized users.
</rationale>
            <ocil clause="the above command returns no output, or if the umask is configured incorrectly">
Verify the <tt>UMASK</tt> setting is configured correctly in the <tt>/etc/login.defs</tt> file by running the following command:
<pre># grep -i "UMASK" /etc/login.defs</pre>
All output must show the value of <tt>umask</tt> set as shown in the below:
<pre># grep -i "UMASK" /etc/login.defs
umask <sub idref="var_accounts_user_umask"/></pre>
</ocil>
            <oval id="accounts_umask_etc_login_defs" value="var_accounts_user_umask"/>
          </Rule>
        </Group>
      </Group>
      <Group id="physical">
        <title>Physical Settings</title>
      </Group>
      <Group id="banners">
        <title>Banners Settings</title>
      </Group>
    </Group>
    <Group id="network">
      <title>Network Settings</title>
      <Group id="kernel">
        <title>Kernel Settings</title>
      </Group>
      <Group id="wireless">
        <title>Wireless Settings</title>
      </Group>
      <Group id="ipv6">
        <title>Ipv6 Settings</title>
      </Group>
      <Group id="firewalld">
        <title>Firewalld Settings</title>
      </Group>
      <Group id="ssl">
        <title>Ssl Settings</title>
      </Group>
      <Group id="uncommon">
        <title>Uncommon Settings</title>
      </Group>
      <Group id="ipsec">
        <title>Ipsec Settings</title>
      </Group>
    </Group>
    <Group id="logging">
      <title>Logging Settings</title>
    </Group>
    <Group id="auditing">
      <title>Auditing Settings</title>
      <Value id="var_auditd_action_mail_acct" type="string">
        <title>Account for auditd to send email when actions occurs</title>
        <description>The setting for action_mail_acct in /etc/audit/auditd.conf</description>
        <value selector="">root</value>
        <value selector="root">root</value>
        <value selector="admin">admin</value>
      </Value>
      <Value id="var_auditd_flush" type="string">
        <title>Auditd priority for flushing data to disk</title>
        <description>The setting for flush in /etc/audit/auditd.conf</description>
        <value selector="">data</value>
        <value selector="none">none</value>
        <value selector="incremental">incremental</value>
        <value selector="data">data</value>
        <value selector="sync">sync</value>
      </Value>
      <Value id="var_auditd_max_log_file_action" type="string">
        <title>Action for auditd to take when log files reach their maximum size</title>
        <description>The setting for max_log_file_action in /etc/audit/auditd.conf</description>
        <value selector="">rotate</value>
        <value selector="ignore">ignore</value>
        <value selector="syslog">syslog</value>
        <value selector="suspend">suspend</value>
        <value selector="rotate">rotate</value>
        <value selector="keep_logs">keep_logs</value>
      </Value>
      <Value id="var_auditd_num_logs" type="number">
        <title>Number of log files for auditd to retain</title>
        <description>The setting for num_logs in /etc/audit/auditd.conf</description>
        <value selector="">5</value>
        <value selector="5">5</value>
        <value selector="4">4</value>
        <value selector="3">3</value>
        <value selector="2">2</value>
        <value selector="1">1</value>
        <value selector="0">0</value>
      </Value>
      <Value id="var_auditd_space_left_action" type="string">
        <title>Action for auditd to take when disk space just starts to run low</title>
        <description>The setting for space_left_action in /etc/audit/auditd.conf</description>
        <value selector="">email</value>
        <value selector="ignore">ignore</value>
        <value selector="syslog">syslog</value>
        <value selector="email">email</value>
        <value selector="exec">exec</value>
        <value selector="suspend">suspend</value>
        <value selector="single">single</value>
        <value selector="halt">halt</value>
      </Value>
    </Group>
  </Group>
  <Group id="services" prodtype="all">
    <title>Services</title>
    <description>
The best protection against vulnerable software is running less software. This section describes how to review
the software which <product-name-macro/> installs on a system and disable software which is not needed. It
then enumerates the software packages installed on a default <product-name-macro/> system and provides guidance about which
ones can be safely disabled.
<br/><br/>
<product-name-macro/> provides a convenient minimal install option that essentially installs the bare necessities for a functional
system. When building <product-name-macro/> systems, it is highly recommended to select the minimal packages and then build up
the system from there.
</description>
    <Group id="cron_and_at">
      <title>Cron and At Daemons</title>
      <description>
The cron and at services are used to allow commands to be executed at a later time.
The cron service is required by almost all systems to perform necessary maintenance tasks, while at may or may not be required on a given system.
Both daemons should be configured defensively.
</description>
    </Group>
    <Group id="ssh">
      <title>ssh Settings</title>
      <Value id="sshd_idle_timeout_value" type="number" operator="equals" interactive="0">
        <title>SSH session Idle time</title>
        <description>Specify duration of allowed idle time.</description>
        <value selector="">300</value>
        <value selector="5_minutes">300</value>
        <value selector="10_minutes">600</value>
        <value selector="15_minutes">900</value>
        <value selector="60_minutes">3600</value>
        <value selector="120_minutes">7200</value>
      </Value>
    </Group>
    <Group id="ntp">
      <title>Ntp Settings</title>
    </Group>
    <Group id="audit">
      <title>Audit Settings</title>
    </Group>
    <Group id="ftp">
      <title>Ftp Settings</title>
    </Group>
    <Group id="snmp">
      <title>Snmp Settings</title>
    </Group>
    <Group id="nfs">
      <title>Nfs Settings</title>
    </Group>
    <Group id="xorg">
      <title>Xorg Settings</title>
    </Group>
  </Group>
</Benchmark>
