<?xml version="1.0"?>
<Benchmark xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xhtml="http://www.w3.org/1999/xhtml" xmlns:dc="http://purl.org/dc/elements/1.1/" id="product-name" xsi:schemaLocation="http://checklists.nist.gov/xccdf/1.1 xccdf-1.1.4.xsd" style="SCAP_1.1" resolved="false" xml:lang="en-US">
  <status date="2011-12-20">draft</status>
  <title>Guide to the Secure Configuration of <product-name-macro/></title>
  <description>This guide presents a catalog of security-relevant
configuration settings for <product-name-macro/>. It is a rendering of
content structured in the eXtensible Configuration Checklist Description Format (XCCDF)
in order to support security automation.  The SCAP content is
is available in the <tt>scap-security-guide</tt> package which is developed at
<weblink-macro link="https://www.open-scap.org/security-policies/scap-security-guide"/>.
<br/>
<br/>
Providing system administrators with such guidance informs them how to securely
configure systems under their control in a variety of network roles. Policy
makers and baseline creators can use this catalog of settings, with its
associated references to higher-level security control catalogs, in order to
assist them in security baseline creation. This guide is a <i>catalog, not a
checklist,</i> and satisfaction of every item is not likely to be possible or
sensible in many operational scenarios. However, the XCCDF format enables
granular selection and adjustment of settings, and their association with OVAL
and OCIL content provides an automated checking capability. Transformations of
this document, and its associated automated checking content, are capable of
providing baselines that meet a diverse set of policy objectives. Some example
XCCDF <i>Profiles</i>, which are selections of items that form checklists and
can be used as baselines, are available with this guide. They can be
processed, in an automated fashion, with tools that support the Security
Content Automation Protocol (SCAP). The DISA STIG for <product-name-macro/>,
which provides required settings for US Department of Defense systems, is
one example of a baseline created from this guidance.
</description>
  <notice id="terms_of_use">Do not attempt to implement any of the settings in
this guide without first testing them in a non-operational environment. The
creators of this guidance assume no responsibility whatsoever for its use by
other parties, and makes no guarantees, expressed or implied, about its
quality, reliability, or any other characteristic.</notice>
  <front-matter xmlns:xccdf="http://checklists.nist.gov/xccdf/1.1">
    <p>
      <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" id="Layer_1" xml:space="preserve" height="140px" viewBox="30 100 330 150" width="350px" version="1.1" y="0px" x="0px" enable-background="new 30 100 330 150">
        <g fill="#3A3B3B">
          <path d="m197.1 150.3s-10.1-1.2-14.4-1.2c-7.2 0-11.0 2.6-11.0 8.3 0 6.6 3.5 7.7 12.3 9.6 10.1 2.3 14.5 4.7 14.5 13.6 0 11.2-6.1 15.6-16.1 15.6-6.0 0-16.0-1.6-16.0-1.6l0.6-4.7s9.9 1.3 15.1 1.3c7.2 0 10.8-3.1 10.8-10.2 0-5.7-3.0-7.3-11.2-8.9-10.4-2.3-15.7-4.7-15.7-14.4 0-9.8 6.4-13.6 16.3-13.6 6.0 0 15.3 1.5 15.3 1.5l-0.5 4.8z"/>
          <path d="m238.7 194.6c-3.6 0.7-9.1 1.5-13.9 1.5-15.1 0-18.5-9.2-18.5-25.9 0-17.1 3.3-26.1 18.5-26.1 5.2 0 10.7 1.0 13.9 1.6l-0.2 4.7c-3.3-0.6-9.2-1.3-13.1-1.3-11.2 0-13.2 6.7-13.2 21.1 0 14.1 1.8 20.8 13.4 20.8 4.1 0 9.5-0.7 13.0-1.3l0.2 4.8z"/>
          <path d="m257.5 144.9h12.3l13.9 50.5h-5.6l-3.7-13.0h-21.6l-3.7 13.0h-5.5l13.9-50.5zm-3.4 32.5h19.1l-7.7-27.7h-3.8l-7.7 27.7z"/>
          <path d="m297.2 178.4v17.0h-5.6v-50.5h18.5c11.0 0 16.1 5.3 16.1 16.3 0 11.0-5.1 17.2-16.1 17.2h-12.9zm12.8-5.0c7.4 0 10.4-4.5 10.4-12.3 0-7.7-3.1-11.3-10.4-11.3h-12.8v23.6h12.8z"/>
        </g>
        <g fill="#676767">
          <path d="m176.8 211.2s-2.8-0.3-4.0-0.3c-1.5 0-2.2 0.5-2.2 1.4 0 0.9 0.5 1.2 2.8 1.9 2.9 0.9 3.8 1.8 3.8 4.0 0 3.0-2.0 4.3-4.7 4.3-1.9 0-4.5-0.6-4.5-0.6l0.3-2.1s2.7 0.4 4.1 0.4c1.5 0 2.1-0.7 2.1-1.8 0-0.8-0.5-1.2-2.4-1.8-3.1-0.9-4.2-1.9-4.2-4.1 0-2.8 1.9-4.0 4.6-4.0 1.8 0 4.5 0.5 4.5 0.5l-0.2 2.2z"/>
          <path d="m180.6 208.7h8.8v2.4h-6.0v3.2h4.8v2.4h-4.9v3.3h6.0v2.4h-8.8v-13.6z"/>
          <path d="m201.2 222.1c-0.9 0.2-2.7 0.5-4.0 0.5-4.2 0-5.2-2.3-5.2-7.0 0-5.2 1.2-7.0 5.2-7.0 1.4 0 3.1 0.3 4.0 0.5l-0.1 2.2c-0.9-0.1-2.6-0.3-3.5-0.3-2.1 0-2.8 0.7-2.8 4.6 0 3.7 0.5 4.6 2.8 4.6 0.9 0 2.6-0.2 3.4-0.3l0.1 2.3z"/>
          <path d="m209.5 220.2c1.6 0 2.4-0.8 2.4-2.4v-9.1h2.8v9.0c0 3.4-1.8 4.8-5.2 4.8-3.4 0-5.2-1.4-5.2-4.8v-9.0h2.8v9.1c0 1.6 0.8 2.4 2.4 2.4z"/>
          <path d="m221.3 217.8v4.6h-2.8v-13.6h5.3c3.1 0 4.8 1.4 4.8 4.5 0 1.9-0.8 3.1-2.0 3.9l1.9 5.2h-3.0l-1.6-4.6h-2.7zm2.5-6.7h-2.5v4.3h2.6c1.4 0 1.9-1.0 1.9-2.2 0-1.3-0.7-2.2-2.0-2.2z"/>
          <path d="m231.9 208.7h2.8v13.6h-2.8v-13.6z"/>
          <path d="m237.4 208.7h10.0v2.4h-3.6v11.2h-2.8v-11.2h-3.6v-2.4z"/>
          <path d="m255.7 222.3h-2.8v-5.5l-4.2-8.1h3.1l2.5 5.4 2.5-5.4h3.1l-4.2 8.1v5.5z"/>
          <path d="m273.4 215.1h4.0v7.1s-2.9 0.5-4.6 0.5c-4.4 0-5.6-2.5-5.6-7.0 0-5.0 1.4-7.0 5.5-7.0 2.1 0 4.7 0.6 4.7 0.6l-0.1 2.1s-2.4-0.3-4.2-0.3c-2.4 0-3.1 0.8-3.1 4.6 0 3.6 0.5 4.6 3.0 4.6 0.8 0 1.7-0.1 1.7-0.1v-2.6h-1.2v-2.4z"/>
          <path d="m286 220.2c1.6 0 2.4-0.8 2.4-2.4v-9.1h2.8v9.0c0 3.4-1.8 4.8-5.2 4.8s-5.2-1.4-5.2-4.8v-9.0h2.8v9.1c0 1.6 0.8 2.4 2.4 2.4z"/>
          <path d="m295.0 208.7h2.8v13.6h-2.8v-13.6z"/>
          <path d="m301.8 222.3v-13.6h4.6c4.7 0 5.8 2.0 5.6 6.5 0 4.6-0.9 7.1-5.8 7.1h-4.6zm4.6-11.2h-1.8v8.8h1.8c2.7 0 2.9-1.6 2.9-4.7 0-3.0-0.3-4.1-3.0-4.1z"/>
          <path d="m315.5 208.7h8.8v2.4h-6.0v3.2h4.8v2.4h-4.8v3.3h6.0v2.4h-8.8v-13.6z"/>
        </g>
        <path d="m116.0 204.9h-2.8c-1.5 0-2.8 1.2-2.8 2.7v19.2c0 1.5 1.3 2.7 2.8 2.7h27.9c1.5 0 2.8-1.2 2.8-2.7v-19.2c0-1.5-1.3-2.7-2.8-2.7h-2.8v-8.2c0-6.1-5.0-11.0-11.2-11.0-6.2 0-11.2 4.9-11.2 11.0v8.2zm5.6-8.2c0-3.0 2.5-5.5 5.6-5.4 3.1 0 5.6 2.4 5.6 5.5v8.2h-11.2v-8.2z" fill="#6D0B2B"/>
        <g fill="#AD1D3F">
          <path d="m106.4 214.7c-16.4 11.4-37.5 7.8-50.0-3.4l11.9-11.7c2.3-1.9 3.4-5.4 1.2-8.8-0.1-0.1-6.7-11.0 2.3-19.8 7.3-7.2 17.8-5.8 23.3-0.3 3.2 3.1 4.9 7.1 4.9 11.4v0.1c0 4.3-1.8 8.5-5.1 11.7-4.0 3.9-9.6 5.4-15.4 4.1-2.1-0.5-4.3 0.8-4.8 2.9-0.5 2.1 0.8 4.2 2.9 4.7 8.4 2.0 16.9-0.3 22.8-6.1 4.9-4.8 7.5-10.9 7.4-17.4-0.0-6.3-2.6-12.3-7.3-16.8-8.2-8.1-23.8-10.3-34.5 0.3-10.7 10.5-6.6 23.8-3.7 28.8l-12.8 12.6c-2.9 2.9-2.3 6.6-0.2 8.7 15.4 15.2 38.7 17.9 56.9 8.2l-0.0-9.1z"/>
          <path d="m43.9 188.4c-1.1-7.5-1.1-21.8 11.2-33.9 8.0-7.9 18.5-12.0 29.5-11.7 10.2 0.3 20.1 4.5 27.1 11.4 7.6 7.4 11.8 17.3 11.9 27.8v0.1c1.16-0.3 2.4-0.4 3.6-0.4 1.5 0 2.9 0.2 4.3 0.6 0-0.1 0.0-0.2 0.0-0.3-0.1-12.5-5.2-24.3-14.2-33.2-8.4-8.3-20.2-13.3-32.4-13.7-13.2-0.5-25.8 4.5-35.4 14.0-9.1 8.9-14.0 20.8-14.0 33.3 0 2.4 0.2 4.8 0.5 7.2 0.6 4.0 1.8 8.1 3.7 12.2 0.9 2.0 3.2 2.8 5.2 1.9 2.0-0.9 2.9-3.1 2.0-5.1-1.5-3.3-2.6-6.8-3.1-10.1z"/>
        </g>
        <circle cy="218.49" cx="127.26" r="3.233" fill="#fff"/>
      </svg>
    </p>
  </front-matter>
  <rear-matter>Red Hat and Red Hat Enterprise Linux are either registered
trademarks or trademarks of Red Hat, Inc. in the United States and other
countries. All other names are registered trademarks or trademarks of their
respective companies.</rear-matter>
  <platform-cpes-macro/>
  <version>0.9</version>
  <metadata/>
  <Profile id="common">
    <title>Common Profile for General-Purpose Ubuntu Systems</title>
    <description>This profile contains items common to general-purpose Ubuntu 1404 installations.</description>
    <!-- partitioning -->
    <select idref="partition_for_tmp" selected="true"/>
    <select idref="partition_for_var" selected="true"/>
    <select idref="partition_for_var_log" selected="true"/>
    <select idref="partition_for_var_log_audit" selected="true"/>
    <select idref="partition_for_home" selected="true"/>
    <!-- services -->
    <select idref="package_auditd_installed" selected="true"/>
    <select idref="package_cron_installed" selected="true"/>
    <select idref="package_ntp_installed" selected="true"/>
    <select idref="package_rsyslog_installed" selected="true"/>
    <select idref="package_telnetd_removed" selected="true"/>
    <select idref="package_inetutils-telnetd_removed" selected="true"/>
    <select idref="package_telnetd-ssl_removed" selected="true"/>
    <select idref="package_nis_removed" selected="true"/>
    <select idref="package_ntpdate_removed" selected="true"/>
    <select idref="service_auditd_enabled" selected="true"/>
    <select idref="service_cron_enabled" selected="true"/>
    <select idref="service_ntpd_enabled" selected="true"/>
    <select idref="service_rsyslog_enabled" selected="true"/>
    <refine-value idref="sshd_idle_timeout_value" selector="5_minutes"/>
    <!-- SSH SERVER HARDENING (Debian security guide 5.1) -->
    <select idref="sshd_set_idle_timeout" selected="true"/>
    <select idref="sshd_disable_root_login" selected="true"/>
    <select idref="sshd_disable_empty_passwords" selected="true"/>
    <select idref="sshd_allow_only_protocol2" selected="true"/>
    <select idref="sshd_set_keepalive" selected="true"/>
    <!-- END OF SSH SERVER HARDENING -->
    <!-- System Logging Requirements -->
    <select idref="rsyslog_files_ownership" selected="true"/>
    <select idref="rsyslog_files_groupownership" selected="true"/>
    <select idref="rsyslog_files_permissions" selected="true"/>
    <select idref="rsyslog_remote_loghost" selected="false"/>
    <select idref="ensure_logrotate_activated" selected="true"/>
    <!-- critical files -->
    <select idref="file_permissions_systemmap" selected="true"/>
    <select idref="file_permissions_etc_shadow" selected="true"/>
    <select idref="file_permissions_etc_gshadow" selected="true"/>
    <select idref="file_permissions_etc_passwd" selected="true"/>
    <select idref="file_permissions_etc_group" selected="true"/>
    <!-- sysctl -->
    <select idref="sysctl_fs_protected_symlinks" selected="true"/>
    <select idref="sysctl_fs_protected_hardlinks" selected="true"/>
    <select idref="sysctl_fs_suid_dumpable" selected="true"/>
    <select idref="sysctl_kernel_randomize_va_space" selected="true"/>
  </Profile>
  <Profile id="anssi_np_nt28_minimal">
    <title>Profile for ANSSI DAT-NT28 Minimal Level</title>
    <description>This profile contains items to be applied systematically.</description>
    <!-- partitioning -->
    <!-- services -->
    <select idref="package_telnetd_removed" selected="true"/>
    <select idref="package_inetutils-telnetd_removed" selected="true"/>
    <select idref="package_telnetd-ssl_removed" selected="true"/>
    <select idref="package_nis_removed" selected="true"/>
    <!-- service apt -->
    <select idref="apt_conf_disallow_unauthenticated" selected="true"/>
    <!-- System Logging Requirements -->
    <!-- critical files -->
    <select idref="file_permissions_etc_shadow" selected="true"/>
    <select idref="file_permissions_etc_gshadow" selected="true"/>
    <select idref="file_permissions_etc_passwd" selected="true"/>
    <select idref="file_permissions_etc_group" selected="true"/>
    <!-- sysctl -->
  </Profile>
  <Profile id="anssi_np_nt28_average" extends="anssi_np_nt28_minimal">
    <title override="true">Profile for ANSSI DAT-NT28 Average (Intermediate) Level</title>
    <description override="true">This profile contains items for GNU/Linux installations already protected by multiple higher level security stacks.</description>
    <!-- partitioning -->
    <select idref="partition_for_tmp" selected="true"/>
    <select idref="partition_for_var" selected="true"/>
    <select idref="partition_for_var_log" selected="true"/>
    <select idref="partition_for_var_log_audit" selected="true"/>
    <select idref="partition_for_home" selected="true"/>
    <!-- services -->
    <select idref="package_ntp_installed" selected="true"/>
    <select idref="package_ntpdate_removed" selected="true"/>
    <select idref="package_rsyslog_installed" selected="true"/>
    <select idref="service_rsyslog_enabled" selected="true"/>
    <refine-value idref="sshd_idle_timeout_value" selector="5_minutes"/>
    <!-- SSH SERVER HARDENING (Debian security guide 5.1) -->
    <select idref="sshd_set_idle_timeout" selected="true"/>
    <select idref="sshd_disable_root_login" selected="true"/>
    <select idref="sshd_disable_empty_passwords" selected="true"/>
    <select idref="sshd_allow_only_protocol2" selected="true"/>
    <select idref="sshd_set_keepalive" selected="true"/>
    <!-- END OF SSH SERVER HARDENING -->
    <!-- System Logging Requirements -->
    <select idref="rsyslog_files_ownership" selected="true"/>
    <select idref="rsyslog_files_groupownership" selected="true"/>
    <select idref="rsyslog_files_permissions" selected="true"/>
    <select idref="rsyslog_remote_loghost" selected="false"/>
    <select idref="ensure_logrotate_activated" selected="true"/>
    <!-- critical files -->
    <select idref="file_permissions_systemmap" selected="true"/>
    <!-- sysctl -->
    <select idref="sysctl_fs_protected_symlinks" selected="true"/>
    <select idref="sysctl_fs_protected_hardlinks" selected="true"/>
    <select idref="sysctl_fs_suid_dumpable" selected="true"/>
    <select idref="sysctl_kernel_randomize_va_space" selected="true"/>
  </Profile>
  <Profile id="anssi_np_nt28_restrictive" extends="anssi_np_nt28_average">
    <title override="true">Profile for ANSSI DAT-NT28 Restrictive Level</title>
    <description override="true">This profile contains items for GNU/Linux installations exposed to unauthenticated flows or multiple sources.</description>
    <!-- partitioning -->
    <select idref="partition_for_tmp" selected="true"/>
    <select idref="partition_for_var" selected="true"/>
    <select idref="partition_for_var_log" selected="true"/>
    <select idref="partition_for_var_log_audit" selected="true"/>
    <select idref="partition_for_home" selected="true"/>
    <!-- services -->
    <select idref="package_auditd_installed" selected="true"/>
    <select idref="package_cron_installed" selected="true"/>
    <select idref="service_auditd_enabled" selected="true"/>
    <select idref="service_ntpd_enabled" selected="true"/>
  </Profile>
  <Profile id="anssi_np_nt28_high" extends="anssi_np_nt28_restrictive">
    <title override="true">Profile for ANSSI DAT-NT28 High (Enforced) Level</title>
    <description override="true">This profile contains items for GNU/Linux installations storing sensitive informations that can be accessible from unauthenticated or uncontroled networks.</description>
    <!-- partitioning -->
    <select idref="grub2_enable_iommu_force" selected="true"/>
    <!-- services -->
    <!-- System Logging Requirements -->
    <!-- critical files -->
    <!-- sysctl -->
  </Profile>
  <Value id="conditional_clause" type="string" operator="equals">
    <title>A conditional clause for check statements.</title>
    <description>A conditional clause for check statements.</description>
    <value>This is a placeholder.</value>
  </Value>
  <Group id="remediation_functions">
    <title>Remediation functions used by the SCAP Security Guide Project</title>
    <description>XCCDF form of the various remediation functions as used by
remediation scripts from the SCAP Security Guide Project</description>
    <Value id="function_fix_audit_syscall_rule" type="string" operator="equals" interactive="0" hidden="true" prohibitChanges="true">
      <title>Remediation function to fix syscall audit rule for given system call</title>
      <description>Function to fix syscall audit rule for given system call. It is
based on example audit syscall rule definitions as outlined in
/usr/share/doc/audit-2.3.7/stig.rules file provided with the audit package. It
will combine multiple system calls belonging to the same syscall group into one
audit rule (rather than to create audit rule per different system call) to
avoid audit infrastructure performance penalty in the case of
'one-audit-rule-definition-per-one-system-call'. See:

	https://www.redhat.com/archives/linux-audit/2014-November/msg00009.html

for further details.

Expects five arguments (each of them is required) in the form of:
  * audit tool                          tool used to load audit rules,
                                        either 'auditctl', or 'augenrules
  * audit rules' pattern                audit rule skeleton for same syscall
  * syscall group                       greatest common string this rule shares
                                        with other rules from the same group
  * architecture                        architecture this rule is intended for
  * full form of new rule to add        expected full form of audit rule as to
                                        be added into audit.rules file

Note: The 2-th up to 4-th arguments are used to determine how many existing
audit rules will be inspected for resemblance with the new audit rule
(5-th argument) the function is going to add. The rule's similarity check
is performed to optimize audit.rules definition (merge syscalls of the same
group into one rule) to avoid the "single-syscall-per-audit-rule" performance
penalty.

Example call:

  PATTERN="-a always,exit -F arch=$ARCH -S .* -F auid&gt;=500 -F auid!=4294967295 -k delete"
  # Use escaped BRE regex to specify rule group
  GROUP="\(rmdir\|unlink\|rename\)"
  FULL_RULE="-a always,exit -F arch=$ARCH -S rmdir -S unlink -S unlinkat -S rename -S renameat -F auid&gt;=500 -F auid!=4294967295 -k delete"
  fix_audit_syscall_rule "auditctl" "$PATTERN" "$GROUP" "$ARCH" "$FULL_RULE"
</description>
      <value selector="">
function fix_audit_syscall_rule {

# Load function arguments into local variables
local tool="$1"
local pattern="$2"
local group="$3"
local arch="$4"
local full_rule="$5"

# Check sanity of the input
if [ $# -ne "5" ]
then
        echo "Usage: fix_audit_syscall_rule 'tool' 'pattern' 'group' 'arch' 'full rule'"
        echo "Aborting."
        exit 1
fi

# Create a list of audit *.rules files that should be inspected for presence and correctness
# of a particular audit rule. The scheme is as follows:
#
# -----------------------------------------------------------------------------------------
#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |
# -----------------------------------------------------------------------------------------
#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |
# -----------------------------------------------------------------------------------------
#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |
#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |
# -----------------------------------------------------------------------------------------
#
declare -a files_to_inspect

# First check sanity of the specified audit tool
if [ "$tool" != 'auditctl' ] &amp;&amp; [ "$tool" != 'augenrules' ]
then
        echo "Unknown audit rules loading tool: $1. Aborting."
        echo "Use either 'auditctl' or 'augenrules'!"
        exit 1
# If audit tool is 'auditctl', then add '/etc/audit/audit.rules'
# file to the list of files to be inspected
elif [ "$tool" == 'auditctl' ]
then
        files_to_inspect=("${files_to_inspect[@]}" '/etc/audit/audit.rules' )
# If audit tool is 'augenrules', then check if the audit rule is defined
# If rule is defined, add '/etc/audit/rules.d/*.rules' to the list for inspection
# If rule isn't defined yet, add '/etc/audit/rules.d/$key.rules' to the list for inspection
elif [ "$tool" == 'augenrules' ]
then
        # Extract audit $key from audit rule so we can use it later
        key=$(expr "$full_rule" : '.*-k[[:space:]]\([^[:space:]]\+\)')
        # Check if particular audit rule is already defined
        IFS=$'\n' matches=($(sed -s -n -e "/${pattern}/!d" -e "/${arch}/!d" -e "/${group}/!d;F" /etc/audit/rules.d/*.rules))
        # Reset IFS back to default
        unset $IFS
        for match in "${matches[@]}"
        do
                files_to_inspect=("${files_to_inspect[@]}" "${match}")
        done
        # Case when particular rule isn't defined in /etc/audit/rules.d/*.rules yet
        if [ ${#files_to_inspect[@]} -eq "0" ]
        then
                files_to_inspect="/etc/audit/rules.d/$key.rules"
                if [ ! -e "$files_to_inspect" ]
                then
                        touch "$files_to_inspect"
                        chmod 0640 "$files_to_inspect"
                fi
        fi
fi

#
# Indicator that we want to append $full_rule into $audit_file by default
local append_expected_rule=0

for audit_file in "${files_to_inspect[@]}"
do

        # Filter existing $audit_file rules' definitions to select those that:
        # * follow the rule pattern, and
        # * meet the hardware architecture requirement, and
        # * are current syscall group specific
        IFS=$'\n' existing_rules=($(sed -e "/${pattern}/!d" -e "/${arch}/!d" -e "/${group}/!d"  "$audit_file"))
        # Reset IFS back to default
        unset $IFS

        # Process rules found case-by-case
        for rule in "${existing_rules[@]}"
        do
                # Found rule is for same arch &amp; key, but differs (e.g. in count of -S arguments)
                if [ "${rule}" != "${full_rule}" ]
                then
                        # If so, isolate just '(-S \w)+' substring of that rule
                        rule_syscalls=$(echo $rule | grep -o -P '(-S \w+ )+')
                        # Check if list of '-S syscall' arguments of that rule is subset
                        # of '-S syscall' list of expected $full_rule
                        if grep -q -- "$rule_syscalls" &lt;&lt;&lt; "$full_rule"
                        then
                                # Rule is covered (i.e. the list of -S syscalls for this rule is
                                # subset of -S syscalls of $full_rule =&gt; existing rule can be deleted
                                # Thus delete the rule from audit.rules &amp; our array
                                sed -i -e "/$rule/d" "$audit_file"
                                existing_rules=("${existing_rules[@]//$rule/}")
                        else
                                # Rule isn't covered by $full_rule - it besides -S syscall arguments
                                # for this group contains also -S syscall arguments for other syscall
                                # group. Example: '-S lchown -S fchmod -S fchownat' =&gt; group='chown'
                                # since 'lchown' &amp; 'fchownat' share 'chown' substring
                                # Therefore:
                                # * 1) delete the original rule from audit.rules
                                # (original '-S lchown -S fchmod -S fchownat' rule would be deleted)
                                # * 2) delete the -S syscall arguments for this syscall group, but
                                # keep those not belonging to this syscall group
                                # (original '-S lchown -S fchmod -S fchownat' would become '-S fchmod'
                                # * 3) append the modified (filtered) rule again into audit.rules
                                # if the same rule not already present
                                #
                                # 1) Delete the original rule
                                sed -i -e "/$rule/d" "$audit_file"
                                # 2) Delete syscalls for this group, but keep those from other groups
                                # Convert current rule syscall's string into array splitting by '-S' delimiter
                                IFS=$'-S' read -a rule_syscalls_as_array &lt;&lt;&lt; "$rule_syscalls"
                                # Reset IFS back to default
                                unset $IFS
                                # Declare new empty string to hold '-S syscall' arguments from other groups
                                new_syscalls_for_rule=''
                                # Walk through existing '-S syscall' arguments
                                for syscall_arg in "${rule_syscalls_as_array[@]}"
                                do
                                        # Skip empty $syscall_arg values
                                        if [ "$syscall_arg" == '' ]
                                        then
                                                continue
                                        fi
                                        # If the '-S syscall' doesn't belong to current group add it to the new list
                                        # (together with adding '-S' delimiter back for each of such item found)
                                        if grep -q -v -- "$group" &lt;&lt;&lt; "$syscall_arg"
                                        then
                                                new_syscalls_for_rule="$new_syscalls_for_rule -S $syscall_arg"
                                        fi
                                done
                                # Replace original '-S syscall' list with the new one for this rule
                                updated_rule=${rule//$rule_syscalls/$new_syscalls_for_rule}
                                # Squeeze repeated whitespace characters in rule definition (if any) into one
                                updated_rule=$(echo "$updated_rule" | tr -s '[:space:]')
                                # 3) Append the modified / filtered rule again into audit.rules
                                #    (but only in case it's not present yet to prevent duplicate definitions)
                                if ! grep -q -- "$updated_rule" "$audit_file"
                                then
                                        echo "$updated_rule" &gt;&gt; "$audit_file"
                                fi
                        fi
                else
                        # $audit_file already contains the expected rule form for this
                        # architecture &amp; key =&gt; don't insert it second time
                        append_expected_rule=1
                fi
        done

        # We deleted all rules that were subset of the expected one for this arch &amp; key.
        # Also isolated rules containing system calls not from this system calls group.
        # Now append the expected rule if it's not present in $audit_file yet
        if [[ ${append_expected_rule} -eq "0" ]]
        then
                echo "$full_rule" &gt;&gt; "$audit_file"
        fi
done

}
</value>
    </Value>
    <Value id="function_fix_audit_watch_rule" type="string" operator="equals" interactive="0" hidden="true" prohibitChanges="true">
      <title>Remediation function to fix audit file system object watch rule for given path</title>
      <description>Function to fix audit file system object watch rule for given path:
  * if rule exists, also verifies the -w bits match the requirements
  * if rule doesn't exist yet, appends expected rule form to $files_to_inspect
    audit rules file, depending on the tool which was used to load audit rules

Expects four arguments (each of them is required) in the form of:
  * audit tool                          tool used to load audit rules,
                                        either 'auditctl', or 'augenrules'
  * path                                value of -w audit rule's argument
  * required access bits                value of -p audit rule's argument
  * key                                 value of -k audit rule's argument

Example call:

  fix_audit_watch_rule "auditctl" "/etc/localtime" "wa" "audit_time_rules"
</description>
      <value selector="">
function fix_audit_watch_rule {

# Load function arguments into local variables
local tool="$1"
local path="$2"
local required_access_bits="$3"
local key="$4"

# Check sanity of the input
if [ $# -ne "4" ]
then
        echo "Usage: fix_audit_watch_rule 'tool' 'path' 'bits' 'key'"
        echo "Aborting."
        exit 1
fi

# Create a list of audit *.rules files that should be inspected for presence and correctness
# of a particular audit rule. The scheme is as follows:
#
# -----------------------------------------------------------------------------------------
# Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |
# -----------------------------------------------------------------------------------------
#       auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |
# -----------------------------------------------------------------------------------------
#       augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |
#       augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |
# -----------------------------------------------------------------------------------------
declare -a files_to_inspect

# Check sanity of the specified audit tool
if [ "$tool" != 'auditctl' ] &amp;&amp; [ "$tool" != 'augenrules' ]
then
        echo "Unknown audit rules loading tool: $1. Aborting."
        echo "Use either 'auditctl' or 'augenrules'!"
        exit 1
# If the audit tool is 'auditctl', then add '/etc/audit/audit.rules'
# into the list of files to be inspected
elif [ "$tool" == 'auditctl' ]
then
        files_to_inspect=("${files_to_inspect[@]}" '/etc/audit/audit.rules')
# If the audit is 'augenrules', then check if rule is already defined
# If rule is defined, add '/etc/audit/rules.d/*.rules' to list of files for inspection.
# If rule isn't defined, add '/etc/audit/rules.d/$key.rules' to list of files for inspection.
elif [ "$tool" == 'augenrules' ]
then
        # Case when particular audit rule is already defined in some of /etc/audit/rules.d/*.rules file
        # Get pair -- filepath : matching_row into @matches array
        IFS=$'\n' matches=($(grep -P "[\s]*-w[\s]+$path" /etc/audit/rules.d/*.rules))
        # Reset IFS back to default
        unset $IFS
        # For each of the matched entries
        for match in "${matches[@]}"
        do
                # Extract filepath from the match
                rulesd_audit_file=$(echo $match | cut -f1 -d ':')
                # Append that path into list of files for inspection
                files_to_inspect=("${files_to_inspect[@]}" "$rulesd_audit_file")
        done
        # Case when particular audit rule isn't defined yet
        if [ ${#files_to_inspect[@]} -eq "0" ]
        then
                # Append '/etc/audit/rules.d/$key.rules' into list of files for inspection
                files_to_inspect="/etc/audit/rules.d/$key.rules"
                # If the $key.rules file doesn't exist yet, create it with correct permissions
                if [ ! -e "$files_to_inspect" ]
                then
                        touch "$files_to_inspect"
                        chmod 0640 "$files_to_inspect"
                fi
        fi
fi

# Finally perform the inspection and possible subsequent audit rule
# correction for each of the files previously identified for inspection
for audit_rules_file in "${files_to_inspect[@]}"
do

        # Check if audit watch file system object rule for given path already present
        if grep -q -P -- "[\s]*-w[\s]+$path" "$audit_rules_file"
        then
                # Rule is found =&gt; verify yet if existing rule definition contains
                # all of the required access type bits

                # Escape slashes in path for use in sed pattern below
                local esc_path=${path//$'/'/$'\/'}
                # Define BRE whitespace class shortcut
                local sp="[[:space:]]"
                # Extract current permission access types (e.g. -p [r|w|x|a] values) from audit rule
                current_access_bits=$(sed -ne "s/$sp*-w$sp\+$esc_path$sp\+-p$sp\+\([rxwa]\{1,4\}\).*/\1/p" "$audit_rules_file")
                # Split required access bits string into characters array
                # (to check bit's presence for one bit at a time)
                for access_bit in $(echo "$required_access_bits" | grep -o .)
                do
                        # For each from the required access bits (e.g. 'w', 'a') check
                        # if they are already present in current access bits for rule.
                        # If not, append that bit at the end
                        if ! grep -q "$access_bit" &lt;&lt;&lt; "$current_access_bits"
                        then
                                # Concatenate the existing mask with the missing bit
                                current_access_bits="$current_access_bits$access_bit"
                        fi
                done
                # Propagate the updated rule's access bits (original + the required
                # ones) back into the /etc/audit/audit.rules file for that rule
                sed -i "s/\($sp*-w$sp\+$esc_path$sp\+-p$sp\+\)\([rxwa]\{1,4\}\)\(.*\)/\1$current_access_bits\3/" "$audit_rules_file"
        else
                # Rule isn't present yet. Append it at the end of $audit_rules_file file
                # with proper key

                echo "-w $path -p $required_access_bits -k $key" &gt;&gt; "$audit_rules_file"
        fi
done
}
</value>
    </Value>
    <Value id="function_package_command" type="string" operator="equals" interactive="0" hidden="true" prohibitChanges="true">
      <title>Remediation function to to install or uninstall packages on RHEL and Fedora systems</title>
      <description>Function to install or uninstall packages on RHEL and Fedora systems.

Example Call(s):

  package_command install aide
  package_command remove telnet-server
</description>
      <value selector="">
function package_command {

# Load function arguments into local variables
local package_operation=$1
local package=$2

# Check sanity of the input
if [ $# -ne "2" ]
then
  echo "Usage: package_command 'install/uninstall' 'rpm_package_name"
  echo "Aborting."
  exit 1
fi

# If dnf is installed, use dnf; otherwise, use yum
if [ -f "/usr/bin/dnf" ] ; then
  install_util="/usr/bin/dnf"
else
  install_util="/usr/bin/yum"
fi

if [ "$package_operation" != 'remove' ] ; then
  # If the rpm is not installed, install the rpm
  if ! /bin/rpm -q --quiet $package; then
    $install_util -y $package_operation $package
  fi
else
  # If the rpm is installed, uninstall the rpm
  if /bin/rpm -q --quiet $package; then
    $install_util -y $package_operation $package
  fi
fi

}
</value>
    </Value>
    <Value id="function_service_command" type="string" operator="equals" interactive="0" hidden="true" prohibitChanges="true">
      <title>Remediation function to enable/disable and start/stop services on RHEL
and Fedora systems</title>
      <description>Function to enable/disable and start/stop services on RHEL and
Fedora systems.

Example Call(s):

  service_command enable bluetooth
  service_command disable bluetooth.service

  Using xinetd:
  service_command disable rsh.socket xinetd=rsh
</description>
      <value selector="">
function service_command {

# Load function arguments into local variables
local service_state=$1
local service=$2
local xinetd=$(echo $3 | cut -d'=' -f2)

# Check sanity of the input
if [ $# -lt "2" ]
then
  echo "Usage: service_command 'enable/disable' 'service_name.service'"
  echo
  echo "To enable or disable xinetd services add \'xinetd=service_name\'"
  echo "as the last argument"
  echo "Aborting."
  exit 1
fi

# If systemctl is installed, use systemctl command; otherwise, use the service/chkconfig commands
if [ -f "/usr/bin/systemctl" ] ; then
  service_util="/usr/bin/systemctl"
else
  service_util="/sbin/service"
  chkconfig_util="/sbin/chkconfig"
fi

# If disable is not specified in arg1, set variables to enable services.
# Otherwise, variables are to be set to disable services.
if [ "$service_state" != 'disable' ] ; then
  service_state="enable"
  service_operation="start"
  chkconfig_state="on"
else
  service_state="disable"
  service_operation="stop"
  chkconfig_state="off"
fi

# If chkconfig_util is not empty, use chkconfig/service commands.
if ! [ "x$chkconfig_util" = x ] ; then
  $service_util $service $service_operation
  $chkconfig_util --level 0123456 $service $chkconfig_state
else
  $service_util $service_operation $service
  $service_util $service_state $service
fi

# Test if local variable xinetd is empty using non-bashism.
# If empty, then xinetd is not being used.
if ! [ "x$xinetd" = x ] ; then
  grep -qi disable /etc/xinetd.d/$xinetd &amp;&amp; \

  if ! [ "$service_operation" != 'disable' ] ; then
    sed -i "s/disable.*/disable         = no/gI" /etc/xinetd.d/$xinetd
  else
    sed -i "s/disable.*/disable         = yes/gI" /etc/xinetd.d/$xinetd
  fi
fi

}
</value>
    </Value>
    <Value id="function_perform_audit_rules_privileged_commands_remediation" type="string" operator="equals" interactive="0" hidden="true" prohibitChanges="true">
      <title>Remediation function to perform remediation for 'audit_rules_privileged_commands' rule</title>
      <description>Function to perform remediation for 'audit_rules_privileged_commands' rule

Expects two arguments:

  audit_tool            tool used to load audit rules
                        One of 'auditctl' or 'augenrules'

  min_auid              Minimum original ID the user logged in with
                        '500' for RHEL-6 and before, '1000' for RHEL-7 and after.

Example Call(s):

  perform_audit_rules_privileged_commands_remediation "auditctl" "500"
  perform_audit_rules_privileged_commands_remediation "augenrules" "1000"
</description>
      <value selector="">
function perform_audit_rules_privileged_commands_remediation {
#
# Load function arguments into local variables
local tool="$1"
local min_auid="$2"

# Check sanity of the input
if [ $# -ne "2" ]
then
        echo "Usage: perform_audit_rules_privileged_commands_remediation 'auditctl | augenrules' '500 | 1000'"
        echo "Aborting."
        exit 1
fi

declare -a files_to_inspect=()

# Check sanity of the specified audit tool
if [ "$tool" != 'auditctl' ] &amp;&amp; [ "$tool" != 'augenrules' ]
then
        echo "Unknown audit rules loading tool: $1. Aborting."
        echo "Use either 'auditctl' or 'augenrules'!"
        exit 1
# If the audit tool is 'auditctl', then:
# * add '/etc/audit/audit.rules'to the list of files to be inspected,
# * specify '/etc/audit/audit.rules' as the output audit file, where
#   missing rules should be inserted
elif [ "$tool" == 'auditctl' ]
then
        files_to_inspect=("/etc/audit/audit.rules")
        output_audit_file="/etc/audit/audit.rules"
#
# If the audit tool is 'augenrules', then:
# * add '/etc/audit/rules.d/*.rules' to the list of files to be inspected
#   (split by newline),
# * specify /etc/audit/rules.d/privileged.rules' as the output file, where
#   missing rules should be inserted
elif [ "$tool" == 'augenrules' ]
then
        IFS=$'\n' files_to_inspect=($(find /etc/audit/rules.d -maxdepth 1 -type f -name *.rules -print))
        output_audit_file="/etc/audit/rules.d/privileged.rules"
fi

# Obtain the list of SUID/SGID binaries on the particular system (split by newline)
# into privileged_binaries array
IFS=$'\n' privileged_binaries=($(find / -xdev -type f -perm -4000 -o -type f -perm -2000 2&gt;/dev/null))

# Keep list of SUID/SGID binaries that have been already handled within some previous iteration
declare -a sbinaries_to_skip=()

# For each found sbinary in privileged_binaries list
for sbinary in "${privileged_binaries[@]}"
do

        # Replace possible slash '/' character in sbinary definition so we could use it in sed expressions below
        sbinary_esc=${sbinary//$'/'/$'\/'}
        # Check if this sbinary wasn't already handled in some of the previous iterations
        # Return match only if whole sbinary definition matched (not in the case just prefix matched!!!)
        if [[ $(sed -ne "/${sbinary_esc}$/p" &lt;&lt;&lt; ${sbinaries_to_skip[@]}) ]]
        then
                # If so, don't process it second time &amp; go to process next sbinary
                continue
        fi

        # Reset the counter of inspected files when starting to check
        # presence of existing audit rule for new sbinary
        local count_of_inspected_files=0

        # For each audit rules file from the list of files to be inspected
        for afile in "${files_to_inspect[@]}"
        do

                # Search current audit rules file's content for match. Match criteria:
                # * existing rule is for the same SUID/SGID binary we are currently processing (but
                #   can contain multiple -F path= elements covering multiple SUID/SGID binaries)
                # * existing rule contains all arguments from expected rule form (though can contain
                #   them in arbitrary order)

                base_search=$(sed -e "/-a always,exit/!d" -e "/-F path=${sbinary_esc}$/!d"   \
                                  -e "/-F path=[^[:space:]]\+/!d" -e "/-F perm=.*/!d"       \
                                  -e "/-F auid&gt;=${min_auid}/!d" -e "/-F auid!=4294967295/!d"  \
                                  -e "/-k privileged/!d" $afile)

                # Increase the count of inspected files for this sbinary
                count_of_inspected_files=$((count_of_inspected_files + 1))

                # Define expected rule form for this binary
                expected_rule="-a always,exit -F path=${sbinary} -F perm=x -F auid&gt;=${min_auid} -F auid!=4294967295 -k privileged"

                # Require execute access type to be set for existing audit rule
                exec_access='x'

                # Search current audit rules file's content for presence of rule pattern for this sbinary
                if [[ $base_search ]]
                then

                        # Current audit rules file already contains rule for this binary =&gt;
                        # Store the exact form of found rule for this binary for further processing
                        concrete_rule=$base_search

                        # Select all other SUID/SGID binaries possibly also present in the found rule
                        IFS=$'\n' handled_sbinaries=($(grep -o -e "-F path=[^[:space:]]\+" &lt;&lt;&lt; $concrete_rule))
                        IFS=$' ' handled_sbinaries=(${handled_sbinaries[@]//-F path=/})

                        # Merge the list of such SUID/SGID binaries found in this iteration with global list ignoring duplicates
                        sbinaries_to_skip=($(for i in "${sbinaries_to_skip[@]}" "${handled_sbinaries[@]}"; do echo $i; done | sort -du))

                        # Separate concrete_rule into three sections using hash '#'
                        # sign as a delimiter around rule's permission section borders
                        concrete_rule=$(echo $concrete_rule | sed -n "s/\(.*\)\+\(-F perm=[rwax]\+\)\+/\1#\2#/p")

                        # Split concrete_rule into head, perm, and tail sections using hash '#' delimiter
                        IFS=$'#' read rule_head rule_perm rule_tail &lt;&lt;&lt;  "$concrete_rule"

                        # Extract already present exact access type [r|w|x|a] from rule's permission section
                        access_type=${rule_perm//-F perm=/}

                        # Verify current permission access type(s) for rule contain 'x' (execute) permission
                        if ! grep -q "$exec_access" &lt;&lt;&lt; "$access_type"
                        then

                                # If not, append the 'x' (execute) permission to the existing access type bits
                                access_type="$access_type$exec_access"
                                # Reconstruct the permissions section for the rule
                                new_rule_perm="-F perm=$access_type"
                                # Update existing rule in current audit rules file with the new permission section
                                sed -i "s#${rule_head}\(.*\)${rule_tail}#${rule_head}${new_rule_perm}${rule_tail}#" $afile

                        fi

                # If the required audit rule for particular sbinary wasn't found yet, insert it under following conditions:
                #
                # * in the "auditctl" mode of operation insert particular rule each time
                #   (because in this mode there's only one file -- /etc/audit/audit.rules to be inspected for presence of this rule),
                #
                # * in the "augenrules" mode of operation insert particular rule only once and only in case we have already
                #   searched all of the files from /etc/audit/rules.d/*.rules location (since that audit rule can be defined
                #   in any of those files and if not, we want it to be inserted only once into /etc/audit/rules.d/privileged.rules file)
                #
                elif [ "$tool" == "auditctl" ] || [[ "$tool" == "augenrules" &amp;&amp; $count_of_inspected_files -eq "${#files_to_inspect[@]}" ]]
                then

                        # Current audit rules file's content doesn't contain expected rule for this
                        # SUID/SGID binary yet =&gt; append it
                        echo $expected_rule &gt;&gt; $output_audit_file
                fi

        done

done

}
</value>
    </Value>
    <Value id="function_populate" type="string" operator="equals" interactive="0" hidden="true" prohibitChanges="true">
      <title>Remediation function to populate environment variables needed for unit testing</title>
      <description>The populate function isn't directly used by SSG at the moment but it can
ba used for testing purposes (to verify proper work of the remediation script directly
from the shell).</description>
      <value selector="">
function populate {
# Code to populate environment variables needed (for unit testing)
if [ -z "${!1}" ]; then
	echo "$1 is not defined. Exiting."
	exit
fi
}
</value>
    </Value>
    <Value id="function_rhel6_perform_audit_adjtimex_settimeofday_stime_remediation" type="string" operator="equals" interactive="0" hidden="true" prohibitChanges="true">
      <title>Remediation function for the 'adjtimex', 'settimeofday', and 'stime'
audit system calls on Red Hat Enterprise Linux 6</title>
      <description>Perform the remediation for the 'adjtimex', 'settimeofday', and 'stime' audit
# system calls on Red Hat Enterprise Linux 6 OS</description>
      <value selector="">
function fix_audit_syscall_rule {

# Load function arguments into local variables
local tool="$1"
local pattern="$2"
local group="$3"
local arch="$4"
local full_rule="$5"

# Check sanity of the input
if [ $# -ne "5" ]
then
        echo "Usage: fix_audit_syscall_rule 'tool' 'pattern' 'group' 'arch' 'full rule'"
        echo "Aborting."
        exit 1
fi

# Create a list of audit *.rules files that should be inspected for presence and correctness
# of a particular audit rule. The scheme is as follows:
# 
# -----------------------------------------------------------------------------------------
#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |
# -----------------------------------------------------------------------------------------
#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |
# -----------------------------------------------------------------------------------------
#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |
#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |
# -----------------------------------------------------------------------------------------
#
declare -a files_to_inspect

# First check sanity of the specified audit tool
if [ "$tool" != 'auditctl' ] &amp;&amp; [ "$tool" != 'augenrules' ]
then
        echo "Unknown audit rules loading tool: $1. Aborting."
        echo "Use either 'auditctl' or 'augenrules'!"
        exit 1
# If audit tool is 'auditctl', then add '/etc/audit/audit.rules'
# file to the list of files to be inspected
elif [ "$tool" == 'auditctl' ]
then
        files_to_inspect=("${files_to_inspect[@]}" '/etc/audit/audit.rules' )
# If audit tool is 'augenrules', then check if the audit rule is defined
# If rule is defined, add '/etc/audit/rules.d/*.rules' to the list for inspection
# If rule isn't defined yet, add '/etc/audit/rules.d/$key.rules' to the list for inspection
elif [ "$tool" == 'augenrules' ]
then
        # Extract audit $key from audit rule so we can use it later
        key=$(expr "$full_rule" : '.*-k[[:space:]]\([^[:space:]]\+\)')
        # Check if particular audit rule is already defined
        IFS=$'\n' matches=($(sed -s -n -e "/${pattern}/!d" -e "/${arch}/!d" -e "/${group}/!d;F" /etc/audit/rules.d/*.rules))
        # Reset IFS back to default
        unset $IFS
        for match in "${matches[@]}"
        do
                files_to_inspect=("${files_to_inspect[@]}" "${match}")
        done
        # Case when particular rule isn't defined in /etc/audit/rules.d/*.rules yet
        if [ ${#files_to_inspect[@]} -eq "0" ]
        then
                files_to_inspect="/etc/audit/rules.d/$key.rules"
                if [ ! -e "$files_to_inspect" ]
                then
                        touch "$files_to_inspect"
                        chmod 0640 "$files_to_inspect"
                fi
        fi
fi

#
# Indicator that we want to append $full_rule into $audit_file by default
local append_expected_rule=0

for audit_file in "${files_to_inspect[@]}"
do

        # Filter existing $audit_file rules' definitions to select those that:
        # * follow the rule pattern, and
        # * meet the hardware architecture requirement, and
        # * are current syscall group specific
        IFS=$'\n' existing_rules=($(sed -e "/${pattern}/!d" -e "/${arch}/!d" -e "/${group}/!d"  "$audit_file"))
        # Reset IFS back to default
        unset $IFS

        # Process rules found case-by-case
        for rule in "${existing_rules[@]}"
        do
                # Found rule is for same arch &amp; key, but differs (e.g. in count of -S arguments)
                if [ "${rule}" != "${full_rule}" ]
                then
                        # If so, isolate just '(-S \w)+' substring of that rule
                        rule_syscalls=$(echo $rule | grep -o -P '(-S \w+ )+')
                        # Check if list of '-S syscall' arguments of that rule is subset
                        # of '-S syscall' list of expected $full_rule
                        if grep -q -- "$rule_syscalls" &lt;&lt;&lt; "$full_rule"
                        then
                                # Rule is covered (i.e. the list of -S syscalls for this rule is
                                # subset of -S syscalls of $full_rule =&gt; existing rule can be deleted
                                # Thus delete the rule from audit.rules &amp; our array
                                sed -i -e "/$rule/d" "$audit_file"
                                existing_rules=("${existing_rules[@]//$rule/}")
                        else
                                # Rule isn't covered by $full_rule - it besides -S syscall arguments
                                # for this group contains also -S syscall arguments for other syscall
                                # group. Example: '-S lchown -S fchmod -S fchownat' =&gt; group='chown'
                                # since 'lchown' &amp; 'fchownat' share 'chown' substring
                                # Therefore:
                                # * 1) delete the original rule from audit.rules
                                # (original '-S lchown -S fchmod -S fchownat' rule would be deleted)
                                # * 2) delete the -S syscall arguments for this syscall group, but
                                # keep those not belonging to this syscall group
                                # (original '-S lchown -S fchmod -S fchownat' would become '-S fchmod'
                                # * 3) append the modified (filtered) rule again into audit.rules
                                # if the same rule not already present
                                #
                                # 1) Delete the original rule
                                sed -i -e "/$rule/d" "$audit_file"
                                # 2) Delete syscalls for this group, but keep those from other groups
                                # Convert current rule syscall's string into array splitting by '-S' delimiter
                                IFS=$'-S' read -a rule_syscalls_as_array &lt;&lt;&lt; "$rule_syscalls"
                                # Reset IFS back to default
                                unset $IFS
                                # Declare new empty string to hold '-S syscall' arguments from other groups
                                new_syscalls_for_rule=''
                                # Walk through existing '-S syscall' arguments
                                for syscall_arg in "${rule_syscalls_as_array[@]}"
                                do
                                        # Skip empty $syscall_arg values
                                        if [ "$syscall_arg" == '' ]
                                        then
                                                continue
                                        fi
                                        # If the '-S syscall' doesn't belong to current group add it to the new list
                                        # (together with adding '-S' delimiter back for each of such item found)
                                        if grep -q -v -- "$group" &lt;&lt;&lt; "$syscall_arg"
                                        then
                                                new_syscalls_for_rule="$new_syscalls_for_rule -S $syscall_arg"
                                        fi
                                done
                                # Replace original '-S syscall' list with the new one for this rule
                                updated_rule=${rule//$rule_syscalls/$new_syscalls_for_rule}
                                # Squeeze repeated whitespace characters in rule definition (if any) into one
                                updated_rule=$(echo "$updated_rule" | tr -s '[:space:]')
                                # 3) Append the modified / filtered rule again into audit.rules
                                #    (but only in case it's not present yet to prevent duplicate definitions)
                                if ! grep -q -- "$updated_rule" "$audit_file"
                                then
                                        echo "$updated_rule" &gt;&gt; "$audit_file"
                                fi
                        fi
                else
                        # $audit_file already contains the expected rule form for this
                        # architecture &amp; key =&gt; don't insert it second time
                        append_expected_rule=1
                fi
        done

        # We deleted all rules that were subset of the expected one for this arch &amp; key.
        # Also isolated rules containing system calls not from this system calls group.
        # Now append the expected rule if it's not present in $audit_file yet
        if [[ ${append_expected_rule} -eq "0" ]]
        then
                echo "$full_rule" &gt;&gt; "$audit_file"
        fi
done

}

function rhel6_perform_audit_adjtimex_settimeofday_stime_remediation {

# Perform the remediation for the 'adjtimex', 'settimeofday', and 'stime' audit
# system calls on Red Hat Enterprise Linux 6 OS
#
# Retrieve hardware architecture of the underlying system
[ $(getconf LONG_BIT) = "32" ] &amp;&amp; RULE_ARCHS=("b32") || RULE_ARCHS=("b32" "b64")

for ARCH in "${RULE_ARCHS[@]}"
do
        PATTERN="-a always,exit -F arch=${ARCH} -S .* -k *"
        # Create expected audit group and audit rule form for particular system call &amp; architecture
        if [ ${ARCH} = "b32" ]
        then
                # stime system call is known at 32-bit arch (see e.g "$ ausyscall i386 stime" 's output)
                # so append it to the list of time group system calls to be audited
                GROUP="\(adjtimex\|settimeofday\|stime\)"
                FULL_RULE="-a always,exit -F arch=${ARCH} -S adjtimex -S settimeofday -S stime -k audit_time_rules"
        elif [ ${ARCH} = "b64" ]
        then
                # stime system call isn't known at 64-bit arch (see "$ ausyscall x86_64 stime" 's output)
                # therefore don't add it to the list of time group system calls to be audited
                GROUP="\(adjtimex\|settimeofday\)"
                FULL_RULE="-a always,exit -F arch=${ARCH} -S adjtimex -S settimeofday -k audit_time_rules"
        fi
        # Perform the remediation itself
        fix_audit_syscall_rule "auditctl" "$PATTERN" "$GROUP" "$ARCH" "$FULL_RULE"
done

}
</value>
    </Value>
    <Value id="function_rhel7_fedora_perform_audit_adjtimex_settimeofday_stime_remediation" type="string" operator="equals" interactive="0" hidden="true" prohibitChanges="true">
      <title>Remediation function for the 'adjtimex', 'settimeofday', and 'stime'
audit system calls on Red Hat Enterprise Linux 7 or Fedora</title>
      <description>Perform the remediation for the 'adjtimex', 'settimeofday', and
'stime' audit system calls on Red Hat Enterprise Linux 7 or Fedora OSes</description>
      <value selector="">
function fix_audit_syscall_rule {

# Load function arguments into local variables
local tool="$1"
local pattern="$2"
local group="$3"
local arch="$4"
local full_rule="$5"

# Check sanity of the input
if [ $# -ne "5" ]
then
        echo "Usage: fix_audit_syscall_rule 'tool' 'pattern' 'group' 'arch' 'full rule'"
        echo "Aborting."
        exit 1
fi

# Create a list of audit *.rules files that should be inspected for presence and correctness
# of a particular audit rule. The scheme is as follows:
# 
# -----------------------------------------------------------------------------------------
#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |
# -----------------------------------------------------------------------------------------
#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |
# -----------------------------------------------------------------------------------------
#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |
#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |
# -----------------------------------------------------------------------------------------
#
declare -a files_to_inspect

# First check sanity of the specified audit tool
if [ "$tool" != 'auditctl' ] &amp;&amp; [ "$tool" != 'augenrules' ]
then
        echo "Unknown audit rules loading tool: $1. Aborting."
        echo "Use either 'auditctl' or 'augenrules'!"
        exit 1
# If audit tool is 'auditctl', then add '/etc/audit/audit.rules'
# file to the list of files to be inspected
elif [ "$tool" == 'auditctl' ]
then
        files_to_inspect=("${files_to_inspect[@]}" '/etc/audit/audit.rules' )
# If audit tool is 'augenrules', then check if the audit rule is defined
# If rule is defined, add '/etc/audit/rules.d/*.rules' to the list for inspection
# If rule isn't defined yet, add '/etc/audit/rules.d/$key.rules' to the list for inspection
elif [ "$tool" == 'augenrules' ]
then
        # Extract audit $key from audit rule so we can use it later
        key=$(expr "$full_rule" : '.*-k[[:space:]]\([^[:space:]]\+\)')
        # Check if particular audit rule is already defined
        IFS=$'\n' matches=($(sed -s -n -e "/${pattern}/!d" -e "/${arch}/!d" -e "/${group}/!d;F" /etc/audit/rules.d/*.rules))
        # Reset IFS back to default
        unset $IFS
        for match in "${matches[@]}"
        do
                files_to_inspect=("${files_to_inspect[@]}" "${match}")
        done
        # Case when particular rule isn't defined in /etc/audit/rules.d/*.rules yet
        if [ ${#files_to_inspect[@]} -eq "0" ]
        then
                files_to_inspect="/etc/audit/rules.d/$key.rules"
                if [ ! -e "$files_to_inspect" ]
                then
                        touch "$files_to_inspect"
                        chmod 0640 "$files_to_inspect"
                fi
        fi
fi

#
# Indicator that we want to append $full_rule into $audit_file by default
local append_expected_rule=0

for audit_file in "${files_to_inspect[@]}"
do

        # Filter existing $audit_file rules' definitions to select those that:
        # * follow the rule pattern, and
        # * meet the hardware architecture requirement, and
        # * are current syscall group specific
        IFS=$'\n' existing_rules=($(sed -e "/${pattern}/!d" -e "/${arch}/!d" -e "/${group}/!d"  "$audit_file"))
        # Reset IFS back to default
        unset $IFS

        # Process rules found case-by-case
        for rule in "${existing_rules[@]}"
        do
                # Found rule is for same arch &amp; key, but differs (e.g. in count of -S arguments)
                if [ "${rule}" != "${full_rule}" ]
                then
                        # If so, isolate just '(-S \w)+' substring of that rule
                        rule_syscalls=$(echo $rule | grep -o -P '(-S \w+ )+')
                        # Check if list of '-S syscall' arguments of that rule is subset
                        # of '-S syscall' list of expected $full_rule
                        if grep -q -- "$rule_syscalls" &lt;&lt;&lt; "$full_rule"
                        then
                                # Rule is covered (i.e. the list of -S syscalls for this rule is
                                # subset of -S syscalls of $full_rule =&gt; existing rule can be deleted
                                # Thus delete the rule from audit.rules &amp; our array
                                sed -i -e "/$rule/d" "$audit_file"
                                existing_rules=("${existing_rules[@]//$rule/}")
                        else
                                # Rule isn't covered by $full_rule - it besides -S syscall arguments
                                # for this group contains also -S syscall arguments for other syscall
                                # group. Example: '-S lchown -S fchmod -S fchownat' =&gt; group='chown'
                                # since 'lchown' &amp; 'fchownat' share 'chown' substring
                                # Therefore:
                                # * 1) delete the original rule from audit.rules
                                # (original '-S lchown -S fchmod -S fchownat' rule would be deleted)
                                # * 2) delete the -S syscall arguments for this syscall group, but
                                # keep those not belonging to this syscall group
                                # (original '-S lchown -S fchmod -S fchownat' would become '-S fchmod'
                                # * 3) append the modified (filtered) rule again into audit.rules
                                # if the same rule not already present
                                #
                                # 1) Delete the original rule
                                sed -i -e "/$rule/d" "$audit_file"
                                # 2) Delete syscalls for this group, but keep those from other groups
                                # Convert current rule syscall's string into array splitting by '-S' delimiter
                                IFS=$'-S' read -a rule_syscalls_as_array &lt;&lt;&lt; "$rule_syscalls"
                                # Reset IFS back to default
                                unset $IFS
                                # Declare new empty string to hold '-S syscall' arguments from other groups
                                new_syscalls_for_rule=''
                                # Walk through existing '-S syscall' arguments
                                for syscall_arg in "${rule_syscalls_as_array[@]}"
                                do
                                        # Skip empty $syscall_arg values
                                        if [ "$syscall_arg" == '' ]
                                        then
                                                continue
                                        fi
                                        # If the '-S syscall' doesn't belong to current group add it to the new list
                                        # (together with adding '-S' delimiter back for each of such item found)
                                        if grep -q -v -- "$group" &lt;&lt;&lt; "$syscall_arg"
                                        then
                                                new_syscalls_for_rule="$new_syscalls_for_rule -S $syscall_arg"
                                        fi
                                done
                                # Replace original '-S syscall' list with the new one for this rule
                                updated_rule=${rule//$rule_syscalls/$new_syscalls_for_rule}
                                # Squeeze repeated whitespace characters in rule definition (if any) into one
                                updated_rule=$(echo "$updated_rule" | tr -s '[:space:]')
                                # 3) Append the modified / filtered rule again into audit.rules
                                #    (but only in case it's not present yet to prevent duplicate definitions)
                                if ! grep -q -- "$updated_rule" "$audit_file"
                                then
                                        echo "$updated_rule" &gt;&gt; "$audit_file"
                                fi
                        fi
                else
                        # $audit_file already contains the expected rule form for this
                        # architecture &amp; key =&gt; don't insert it second time
                        append_expected_rule=1
                fi
        done

        # We deleted all rules that were subset of the expected one for this arch &amp; key.
        # Also isolated rules containing system calls not from this system calls group.
        # Now append the expected rule if it's not present in $audit_file yet
        if [[ ${append_expected_rule} -eq "0" ]]
        then
                echo "$full_rule" &gt;&gt; "$audit_file"
        fi
done

}

function rhel7_fedora_perform_audit_adjtimex_settimeofday_stime_remediation {

# Perform the remediation for the 'adjtimex', 'settimeofday', and 'stime' audit
# system calls on Red Hat Enterprise Linux 7 or Fedora OSes
#
# Retrieve hardware architecture of the underlying system
[ $(getconf LONG_BIT) = "32" ] &amp;&amp; RULE_ARCHS=("b32") || RULE_ARCHS=("b32" "b64")

for ARCH in "${RULE_ARCHS[@]}"
do

        PATTERN="-a always,exit -F arch=${ARCH} -S .* -k *"
        # Create expected audit group and audit rule form for particular system call &amp; architecture
        if [ ${ARCH} = "b32" ]
        then
                # stime system call is known at 32-bit arch (see e.g "$ ausyscall i386 stime" 's output)
                # so append it to the list of time group system calls to be audited
                GROUP="\(adjtimex\|settimeofday\|stime\)"
                FULL_RULE="-a always,exit -F arch=${ARCH} -S adjtimex -S settimeofday -S stime -k audit_time_rules"
        elif [ ${ARCH} = "b64" ]
        then
                # stime system call isn't known at 64-bit arch (see "$ ausyscall x86_64 stime" 's output)
                # therefore don't add it to the list of time group system calls to be audited
                GROUP="\(adjtimex\|settimeofday\)"
                FULL_RULE="-a always,exit -F arch=${ARCH} -S adjtimex -S settimeofday -k audit_time_rules"
        fi
        # Perform the remediation for both possible tools: 'auditctl' and 'augenrules'
        fix_audit_syscall_rule "auditctl" "$PATTERN" "$GROUP" "$ARCH" "$FULL_RULE"
        fix_audit_syscall_rule "augenrules" "$PATTERN" "$GROUP" "$ARCH" "$FULL_RULE"
done

}
</value>
    </Value>
    <Value id="function_replace_or_append" type="string" operator="equals" interactive="0" hidden="true" prohibitChanges="true">
      <title>Remediation function to replace configuration setting in config file or
add the configuration setting if it does not exist yet</title>
      <description>Function to replace configuration setting in config file or add
the configuration setting if it does not exist.

Expects four arguments:

  config_file:		Configuration file that will be modified
  key:			Configuration option to change
  value:		Value of the configuration option to change
  cce:			The CCE identifier or '$CCENUM' if no CCE identifier exists

Optional arguments:

  format:		Optional argument to specify the format of how key/value should be
			modified/appended in the configuration file. The default is key = value.

Example Call(s):

  With default format of 'key = value':
  replace_or_append '/etc/sysctl.conf' '^kernel.randomize_va_space' '2' '$CCENUM'

  With custom key/value format:
  replace_or_append '/etc/sysconfig/selinux' '^SELINUX=' 'disabled' '$CCENUM' '%s=%s'

  With a variable:
  replace_or_append '/etc/sysconfig/selinux' '^SELINUX=' $var_selinux_state '$CCENUM' '%s=%s'
</description>
      <value selector="">
function replace_or_append {
  local config_file=$1
  local key=$2
  local value=$3
  local cce=$4
  local format=$5

  # Check sanity of the input
  if [ $# -lt "3" ]
  then
        echo "Usage: replace_or_append 'config_file_location' 'key_to_search' 'new_value'"
        echo
        echo "If symlinks need to be taken into account, add yes/no to the last argument"
        echo "to allow to 'follow_symlinks'."
        echo "Aborting."
        exit 1
  fi

  # Test if the config_file is a symbolic link. If so, use --follow-symlinks with sed.
  # Otherwise, regular sed command will do.
  if test -L $config_file; then
    sed_command="sed -i --follow-symlinks"
  else
    sed_command="sed -i"
  fi

  # Test that the cce arg is not empty or does not equal $CCENUM.
  # If $CCENUM exists, it means that there is no CCE assigned.
  if ! [ "x$cce" = x ] &amp;&amp; [ "$cce" != '$CCENUM' ]; then
    cce="CCE-${cce}"
  else
    cce="CCE"
  fi

  # Strip any search characters in the key arg so that the key can be replaced without
  # adding any search characters to the config file.
  stripped_key=$(sed "s/[\^=\$,;+]*//g" &lt;&lt;&lt; $key)

  # If there is no print format specified in the last arg, use the default format.
  if ! [ "x$format" = x ] ; then
    printf -v formatted_output "$format" $stripped_key $value
  else
    formatted_output="$stripped_key = $value"
  fi

  # If the key exists, change it. Otherwise, add it to the config_file.
  if `grep -qi $key $config_file` ; then
    $sed_command "s/$key.*/$formatted_output/g" $config_file
  else
    # \n is precaution for case where file ends without trailing newline
    echo -e "\n# Per $cce: Set $formatted_output in $config_file" &gt;&gt; $config_file
    echo -e "$formatted_output" &gt;&gt; $config_file
  fi

}
</value>
    </Value>
    <Value id="function_firefox_js_setting" type="string" operator="equals" interactive="0" hidden="true" prohibitChanges="true">
      <title>Remediation function to replace configuration setting(s) in the Firefox
preferences JavaScript file or add the preference if it does not exist yet</title>
      <description>Function to replace configuration setting(s) in the Firefox
preferences JavaScript file or add the preference if it does not exist.

Expects three arguments:

  config_file:          Configuration file that will be modified
  key:                  Configuration option to change
  value:                Value of the configuration option to change


Example Call(s):

  Without string or variable:
  firefox_js_setting "stig_settings.js" "general.config.obscure_value" "0"

  With string:
  firefox_js_setting "stig_settings.js" "general.config.filename" "\"stig.cfg\""

  With a string variable:
  firefox_js_setting "stig_settings.js" "general.config.filename" "\"$var_config_file_name\""
</description>
      <value selector="">
function firefox_js_setting {
  local firefox_js=$1
  local key=$2
  local value=$3
  local firefox_dirs="/usr/lib/firefox /usr/lib64/firefox /usr/local/lib/firefox /usr/local/lib64/firefox"
  local firefox_pref="/defaults/pref"
  local firefox_preferences="/defaults/preferences"

  # Check sanity of input
  if [ $# -lt "3" ]
  then
        echo "Usage: firefox_js_setting 'config_javascript_file' 'key_to_search' 'new_value'"
        echo
        echo "Aborting."
        exit 1
  fi

  # Check the possible Firefox install directories
  for firefox_dir in ${firefox_dirs}; do
    # If the Firefox directory exists, then Firefox is installed
    if [ -d "${firefox_dir}" ]; then
      # Different versions of Firefox have different preferences directories, check for them and set the right one
      if [ -d "${firefox_dir}/${firefox_pref}" ] ; then
        local firefox_pref_dir="${firefox_dir}/${firefox_pref}"
      elif [ -d "${firefox_dir}/${firefox_preferences}" ] ; then
        local firefox_pref_dir="${firefox_dir}/${firefox_preferences}"
      else
        mkdir -m 755 -p "${firefox_dir}/${firefox_preferences}"
        local firefox_pref_dir="${firefox_dir}/${firefox_preferences}"
      fi

      # Make sure the Firefox .js file exists and has the appropriate permissions
      if ! [ -f "${firefox_pref_dir}/${firefox_js}" ] ; then
        touch "${firefox_pref_dir}/${firefox_js}"
        chmod 644 "${firefox_pref_dir}/${firefox_js}"
      fi

      # If the key exists, change it. Otherwise, add it to the config_file.
      if `grep -q "^pref(\"${key}\", " "${firefox_pref_dir}/${firefox_js}"` ; then
        sed -i "s/pref(\"${key}\".*/pref(\"${key}\", ${value});/g" "${firefox_pref_dir}/${firefox_js}"
      else
        echo "pref(\"${key}\", ${value});" &gt;&gt; "${firefox_pref_dir}/${firefox_js}"
      fi
    fi
  done

}
</value>
    </Value>
    <Value id="function_firefox_cfg_setting" type="string" operator="equals" interactive="0" hidden="true" prohibitChanges="true">
      <title>Remediation function to replace configuration setting(s) in the Firefox
preferences configuration (.cfg) file or add the preference if it does not exist yet</title>
      <description>Function to replace configuration setting(s) in the Firefox
preferences configuration (.cfg) file or add the preference if it does not exist.

Expects three arguments:

  config_file:          Configuration file that will be modified
  key:                  Configuration option to change
  value:                Value of the configuration option to change


Example Call(s):

  Without string or variable:
  firefox_cfg_setting "stig.cfg" "extensions.update.enabled" "false"

  With string:
  firefox_cfg_setting "stig.cfg" "security.default_personal_cert" "\"Ask Every Time\""

  With a string variable:
  firefox_cfg_setting "stig.cfg" "browser.startup.homepage\" "\"${var_default_home_page}\""
</description>
      <value selector="">
function firefox_cfg_setting {
  local firefox_cfg=$1
  local key=$2
  local value=$3
  local firefox_dirs="/usr/lib/firefox /usr/lib64/firefox /usr/local/lib/firefox /usr/local/lib64/firefox"

  # Check sanity of input
  if [ $# -lt "3" ]
  then
        echo "Usage: firefox_cfg_setting 'config_cfg_file' 'key_to_search' 'new_value'"
        echo
        echo "Aborting."
        exit 1
  fi

  # Check the possible Firefox install directories
  for firefox_dir in ${firefox_dirs}; do
    # If the Firefox directory exists, then Firefox is installed
    if [ -d "${firefox_dir}" ]; then
      # Make sure the Firefox .cfg file exists and has the appropriate permissions
      if ! [ -f "${firefox_dir}/${firefox_cfg}" ] ; then
        touch "${firefox_dir}/${firefox_cfg}"
        chmod 644 "${firefox_dir}/${firefox_cfg}"
      fi

      # If the key exists, change it. Otherwise, add it to the config_file.
      if `grep -q "^lockPref(\"${key}\", " "${firefox_dir}/${firefox_cfg}"` ; then
        sed -i "s/lockPref(\"${key}\".*/lockPref(\"${key}\", ${value});/g" "${firefox_dir}/${firefox_cfg}"
      else
        echo "lockPref(\"${key}\", ${value});" &gt;&gt; "${firefox_dir}/${firefox_cfg}"
      fi
    fi
  done
}
</value>
    </Value>
  </Group>
  <Group id="intro" prodtype="all">
    <title>Introduction</title>
    <description><!-- purpose and scope of guidance -->
The purpose of this guidance is to provide security configuration
recommendations and baselines for the <product-name-macro/> operating
system. Recommended settings for the basic operating system are provided,
as well as for many network services that the system can provide to other systems.
<!-- audience -->The guide is intended for system administrators. Readers are assumed to
possess basic system administration skills for Unix-like systems, as well
as some familiarity with the product's documentation and administration
conventions. Some instructions within this guide are complex.
All directions should be followed completely and with understanding of
their effects in order to avoid serious adverse effects on the system
and its security.
</description>
    <Group id="general-principles" prodtype="all">
      <title>General Principles</title>
      <description>
The following general principles motivate much of the advice in this
guide and should also influence any configuration decisions that are
not explicitly covered.
</description>
      <Group id="principle-encrypt-transmitted-data" prodtype="all">
        <title>Encrypt Transmitted Data Whenever Possible</title>
        <description>
Data transmitted over a network, whether wired or wireless, is susceptible
to passive monitoring. Whenever practical solutions for encrypting
such data exist, they should be applied. Even if data is expected to
be transmitted only over a local network, it should still be encrypted.
Encrypting authentication data, such as passwords, is particularly
important. Networks of <product-name-macro/> machines can and should be configured
so that no unencrypted authentication data is ever transmitted between
machines.
</description>
      </Group>
      <Group id="principle-minimize-software" prodtype="all">
        <title>Minimize Software to Minimize Vulnerability</title>
        <description>
The simplest way to avoid vulnerabilities in software is to avoid
installing that software. On <product-name-macro/>,
<os-type-macro type="rhel7,rhel6,rhel5,fedora,opensuse,suse11,suse12,osp7,eap5,fuse6,wrlinux">the RPM Package Manager (originally Red Hat
Package Manager, abbreviated RPM)</os-type-macro><os-type-macro type="debian">
the Package Manager (originally
<weblink-macro link="https://www.debian.org/doc/manuals/debian-faq/ch-pkgtools.en.html" text="apt"/>)</os-type-macro>
allows for careful management of
the set of software packages installed on a system. Installed software
contributes to system vulnerability in several ways. Packages that
include setuid programs may provide local attackers a potential path to
privilege escalation. Packages that include network services may give
this opportunity to network-based attackers. Packages that include
programs which are predictably executed by local users (e.g. after
graphical login) may provide opportunities for trojan horses or other
attack code to be run undetected. The number of software packages
installed on a system can almost always be significantly pruned to include
only the software for which there is an environmental or operational need.
</description>
      </Group>
      <Group id="principle-separate-servers" prodtype="all">
        <title>Run Different Network Services on Separate Systems</title>
        <description>
Whenever possible, a server should be dedicated to serving exactly one
network service. This limits the number of other services that can
be compromised in the event that an attacker is able to successfully
exploit a software flaw in one network service.
</description>
      </Group>
      <Group id="principle-use-security-tools" prodtype="all">
        <title>Configure Security Tools to Improve System Robustness</title>
        <description>
Several tools exist which can be effectively used to improve a system's
resistance to and detection of unknown attacks. These tools can improve
robustness against attack at the cost of relatively little configuration
effort. In particular, this guide recommends and discusses the use of
host-based firewalling, SELinux for protection against
vulnerable services, and a logging and auditing infrastructure for
detection of problems.
</description>
      </Group>
      <Group id="principle-least-privilege" prodtype="all">
        <title>Least Privilege</title>
        <description>
Grant the least privilege necessary for user accounts and software to perform tasks.
For example, <tt>sudo</tt> can be implemented to limit authorization to super user
accounts on the system only to designated personnel. Another example is to limit
logins on server systems to only those administrators who need to log into them in
order to perform administration tasks. Using SELinux also follows the principle of
least privilege: SELinux policy can confine software to perform only actions on the
system that are specifically allowed. This can be far more restrictive than the
actions permissible by the traditional Unix permissions model.
</description>
      </Group>
    </Group>
    <Group id="how-to-use" prodtype="all">
      <title>How to Use This Guide</title>
      <description>
Readers should heed the following points when using the guide.
</description>
      <Group id="intro-read-sections-completely" prodtype="all">
        <title>Read Sections Completely and in Order</title>
        <description>
Each section may build on information and recommendations discussed in
prior sections. Each section should be read and understood completely;
instructions should never be blindly applied. Relevant discussion may
occur after instructions for an action. 
</description>
      </Group>
      <Group id="intro-test-non-production" prodtype="all">
        <title>Test in Non-Production Environment</title>
        <description>
This guidance should always be tested in a non-production environment
before deployment. This test environment should simulate the setup in
which the system will be deployed as closely as possible.
</description>
      </Group>
      <Group id="intro-root-shell-assumed" prodtype="all">
        <title>Root Shell Environment Assumed</title>
        <description>
Most of the actions listed in this document are written with the
assumption that they will be executed by the root user running the
<tt>/bin/bash</tt> shell. Commands preceded with a hash mark (#)
assume that the administrator will execute the commands as root, i.e.
apply the command via <tt>sudo</tt> whenever possible, or use
<tt>su</tt> to gain root privileges if <tt>sudo</tt> cannot be
used. Commands which can be executed as a non-root user are are preceded
by a dollar sign ($) prompt.
</description>
      </Group>
      <Group id="intro-formatting-conventions" prodtype="all">
        <title>Formatting Conventions</title>
        <description>
Commands intended for shell execution, as well as configuration file text,
are featured in a <tt>monospace font</tt>. <i>Italics</i> are used
to indicate instances where the system administrator must substitute
the appropriate information into a command or configuration file.
</description>
      </Group>
      <Group id="intro-reboot-required" prodtype="all">
        <title>Reboot Required</title>
        <description>
A system reboot is implicitly required after some actions in order to
complete the reconfiguration of the system. In many cases, the changes
will not take effect until a reboot is performed. In order to ensure
that changes are applied properly and to test functionality, always
reboot the system after applying a set of recommendations from this guide.
</description>
      </Group>
    </Group>
  </Group>
  <Group id="system" prodtype="all">
    <title>System Settings</title>
    <description>Contains rules that check correct system settings.</description>
    <!-- HW install -->
    <Group id="hw-install">
      <title>Hardening the hardware usage</title>
      <description>Hardware dependent, but efficient against various risks.</description>
      <Rule id="grub2_enable_iommu_force">
        <title>IOMMU configuration directive</title>
        <description>
    On x86 architecture supporting VT-d, the IOMMU manages the access control policy between the hardware devices and some
    of the system critical units such as the memory.
  </description>
        <rationale>On x86 architectures, activating the I/OMMU prevents the system from arbritrary accesses potentially made by
    hardware devices.</rationale>
        <oval id="grub2_enable_iommu_force"/>
        <ref anssi="NT28(R11)"/>
      </Rule>
    </Group>
    <Group id="software" prodtype="all">
      <title>Installing and Maintaining Software</title>
      <description>The following sections contain information on
security-relevant choices during the initial operating system
installation process and the setup of software
updates.</description>
    </Group>
    <Group id="permissions" prodtype="all">
      <title>File Permissions and Masks</title>
      <description>Traditional Unix security relies heavily on file and
directory permissions to prevent unauthorized users from reading or
modifying files to which they should not have access. 
<br/><br/>
Several of the commands in this section search filesystems
for files or directories with certain characteristics, and are
intended to be run on every local partition on a given system.
When the variable <i>PART</i> appears in one of the commands below,
it means that the command is intended to be run repeatedly, with the
name of each local partition substituted for <i>PART</i> in turn.
<br/><br/>
The following command prints a list of all xfs partitions on the local
system, which is the default filesystem for Red Hat Enterprise Linux
7 installations:
<pre>$ mount -t xfs | awk '{print $3}'</pre>
For any systems that use a different
local filesystem type, modify this command as appropriate.
</description>
      <Group id="files">
        <title>Verify Permissions on Important Files and
Directories</title>
        <description>Permissions for many files on a system must be set
restrictively to ensure sensitive information is properly protected.
This section discusses important
permission restrictions which can be verified
to ensure that no harmful discrepancies have
arisen.</description>
        <Group id="permission_important_state_files">
          <title>Verify permissions on files containing sensitive informations about the system</title>
          <description>Various files contains sensitive informations that can leads to specific weaknesses or
give structural informations for local exploits.</description>
          <Rule id="file_permissions_systemmap">
            <title>Verify that local System.map file (if exists) is readable only by root</title>
            <description>Files containing sensitive informations should be protected by restrictive
  permissions. Most of the time, there is no need that these files need to be read by any non-root user
    <fileperms-desc-macro file="/boot/System.map-*" perms="0600"/>
    <fileowner-desc-macro file="/boot/System.map-*" owner="root"/>
  </description>
            <ocil>
              <fileperms-check-macro file="/boot/Sysem.map-*" perms="-rw-------"/>
              <fileowner-check-macro file="/boot/System.map-*" owner="root"/>
            </ocil>
            <rationale>The <tt>System.map</tt> file contains information about kernel symbols and
  can give some hints to generate local exploitation.
  </rationale>
            <oval id="file_permissions_systemmap"/>
            <ref anssi="NT28(R13)"/>
          </Rule>
        </Group>
        <Group id="permissions_important_account_files">
          <title>Verify Permissions on Files with Local Account Information and Credentials</title>
          <description>The default restrictive permissions for files which act as
important security databases such as <tt>passwd</tt>, <tt>shadow</tt>,
<tt>group</tt>, and <tt>gshadow</tt> files must be maintained.  Many utilities
need read access to the <tt>passwd</tt> file in order to function properly, but
read access to the <tt>shadow</tt> file allows malicious attacks against system
passwords, and should never be enabled.</description>
          <Rule id="file_permissions_etc_shadow" severity="medium">
            <title>Verify Permissions and ownership on <tt>shadow</tt> File</title>
            <description>
              <fileperms-desc-macro file="/etc/shadow" perms="0640"/>
              <fileowner-desc-macro file="/etc/shadow" owner="root"/>
              <filegroupowner-desc-macro file="/etc/shadow" group="shadow"/>
            </description>
            <ocil>
              <fileperms-check-macro file="/etc/shadow" perms="-rw-r-----"/>
              <fileowner-check-macro file="/etc/shadow" owner="root"/>
              <filegroupowner-check-macro file="/etc/shadow" group="shadow"/>
            </ocil>
            <rationale>The <tt>/etc/shadow</tt> file contains the list of local
system accounts and stores password hashes. Protection of this file is
critical for system security. Failure to give ownership of this file
to root provides the designated owner with access to sensitive information
which could weaken the system security posture.</rationale>
            <oval id="file_permissions_etc_shadow"/>
            <ref nist="AC-6" disa="" pcidss="Req-8.7.c" anssi="NT28(R36)"/>
          </Rule>
          <Rule id="file_permissions_etc_gshadow" severity="medium">
            <title>Verify Permissions and ownership on <tt>gshadow</tt> File</title>
            <description>
              <fileperms-desc-macro file="/etc/gshadow" perms="0640"/>
              <fileowner-desc-macro file="/etc/gshadow" owner="root"/>
              <filegroupowner-desc-macro file="/etc/gshadow" group="shadow"/>
            </description>
            <ocil>
              <fileperms-check-macro file="/etc/gshadow" perms="-rw-r-----"/>
              <fileowner-check-macro file="/etc/gshadow" owner="root"/>
              <filegroupowner-check-macro file="/etc/gshadow" group="shadow"/>
            </ocil>
            <rationale>The <tt>/etc/shadow</tt> file contains group password hashes. Protection of this file
is critical for system security.</rationale>
            <oval id="file_permissions_etc_gshadow"/>
            <ref nist="AC-6" disa="" anssi="NT28(R36)"/>
          </Rule>
          <Rule id="file_permissions_etc_passwd" severity="medium">
            <title>Verify Permissions and ownership on <tt>passwd</tt> File</title>
            <description>
              <fileperms-desc-macro file="/etc/passwd" perms="0644"/>
              <fileowner-desc-macro file="/etc/passwd" owner="root"/>
              <filegroupowner-desc-macro file="/etc/passwd" group="root"/>
            </description>
            <ocil>
              <fileperms-check-macro file="/etc/passwd" perms="-rw-r--r--"/>
              <fileowner-check-macro file="/etc/passwd" owner="root"/>
              <filegroupowner-check-macro file="/etc/passwd" group="root"/>
            </ocil>
            <rationale>The <tt>/etc/shadow</tt> file contains information about the users that are configured on
the system. Protection of this file is critical for system security.</rationale>
            <oval id="file_permissions_etc_passwd"/>
            <ref nist="AC-6" disa=""/>
          </Rule>
          <Rule id="file_permissions_etc_group" severity="medium">
            <title>Verify Permissions and ownership on <tt>group</tt> File</title>
            <description>
              <fileperms-desc-macro file="/etc/passwd" perms="0644"/>
              <fileowner-desc-macro file="/etc/passwd" owner="root"/>
              <filegroupowner-desc-macro file="/etc/passwd" group="root"/>
            </description>
            <ocil>
              <fileperms-check-macro file="/etc/passwd" perms="-rw-r--r--"/>
              <fileowner-check-macro file="/etc/passwd" owner="root"/>
              <filegroupowner-check-macro file="/etc/passwd" group="root"/>
            </ocil>
            <rationale>The <tt>/etc/shadow</tt> file contains information about the groups that are configured on
the system. Protection of this file is critical for system security.</rationale>
            <oval id="file_permissions_etc_group"/>
            <ref nist="AC-6" disa=""/>
          </Rule>
        </Group>
      </Group>
      <Group id="restriction">
        <title>Restrict Programs from Dangerous Execution Patterns</title>
        <description>The recommendations in this section are designed to
ensure that the system's features to protect against potentially
dangerous program execution are activated.
These protections are applied at the system initialization or
kernel level, and defend against certain types of badly-configured
or compromised programs.</description>
        <Group id="coredumps">
          <title>Disable Core Dumps</title>
          <description>A core dump file is the memory image of an executable
program when it was terminated by the operating system due to
errant behavior. In most cases, only software developers
legitimately need to access these files. The core dump files may
also contain sensitive information, or unnecessarily occupy large
amounts of disk space.
<br/><br/>
Once a hard limit is set in <tt>/etc/security/limits.conf</tt>, a
user cannot increase that limit within his or her own session. If access
to core dumps is required, consider restricting them to only
certain users or groups. See the <tt>limits.conf</tt> man page for more
information.
<br/><br/>
The core dumps of setuid programs are further protected. The
<tt>sysctl</tt> variable <tt>fs.suid_dumpable</tt> controls whether
the kernel allows core dumps from these programs at all. The default
value of 0 is recommended.</description>
          <Rule id="sysctl_fs_suid_dumpable">
            <title>Disable Core Dumps for SUID programs</title>
            <description>
              <sysctl-desc-macro sysctl="fs.suid_dumpable" value="0"/>
            </description>
            <ocil>
              <sysctl-check-macro sysctl="fs.suid_dumpable" value="0"/>
            </ocil>
            <rationale>The core dump of a setuid program is more likely to contain
wve data, as the program itself runs with greater privileges than the
user who initiated execution of the program.  Disabling the ability for any
setuid program to write a core file decreases the risk of unauthorized access
of such data.</rationale>
            <oval id="sysctl_fs_suid_dumpable"/>
            <ref nist="SI-11" cis="1.6.1" anssi="NT28(R23)"/>
          </Rule>
        </Group>
        <Group id="enable_execshield_settings">
          <title>Enable ExecShield</title>
          <description>ExecShield describes kernel features that provide
protection against exploitation of memory corruption errors such as buffer
overflows. These features include random placement of the stack and other
memory regions, prevention of execution in memory that should only hold data,
and special handling of text buffers. These protections are enabled by default
on 32-bit systems and controlled through <tt>sysctl</tt> variables 
<tt>kernel.exec-shield</tt> and <tt>kernel.randomize_va_space</tt>. On the latest
64-bit systems, <tt>kernel.exec-shield</tt> cannot be enabled or disabled with 
<tt>sysctl</tt>.
</description>
          <Rule id="sysctl_kernel_randomize_va_space" severity="medium">
            <title>Enable Randomized Layout of Virtual Address Space</title>
            <description>
              <sysctl-desc-macro sysctl="kernel.randomize_va_space" value="2"/>
            </description>
            <ocil>
              <sysctl-check-macro sysctl="kernel.randomize_va_space" value="2"/>
            </ocil>
            <rationale> Address space layout randomization (ASLR) makes it more difficult
for an attacker to predict the location of attack code they have introduced
into a process's address space during an attempt at exploitation.  Additionally, ASLR 
makes it more difficult for an attacker to know the location of existing code
in order to re-purpose it using return oriented programming (ROP) techniques.
</rationale>
            <oval id="sysctl_kernel_randomize_va_space"/>
            <ref nist="SC-30(2)" cis="1.6.1" anssi="NT28(R23)"/>
          </Rule>
          <Rule id="sysctl_kernel_kptr_restrict" severity="low">
            <title>Restrict exposed kernel pointers addresses access</title>
            <description>
              <sysctl-desc-macro sysctl="kernel.kptr_restrict" value="1"/>
            </description>
            <ocil>
              <sysctl-check-macro sysctl="kernel.kptr_restrict" value="1"/>
            </ocil>
            <rationale>Exposing kernel pointers (through procfs or <tt>seq_printf()</tt>) exposes
kernel writeable structures that can contain functions pointers. If a write vulnereability occurs
in the kernel allowing a write access to any of this structure, the kernel can be compromise. This
option disallow any program withtout the CAP_SYSLOG capability from getting the kernel pointers addresses,
replacing them with 0.
</rationale>
            <oval id="sysctl_kernel_kptr_restrict"/>
            <ref anssi="NT28(R23)"/>
          </Rule>
        </Group>
      </Group>
    </Group>
    <!-- partitioning -->
    <Group id="fs-part">
      <title>Hardening the filesystem</title>
      <description>Hardening the filesystem and its usage is an efficient way to ensure an efficient separation of services,
data and configurations while ensuring a more precise management of filesystem level access rights, enabling deactivation
of some specific rights at the filesystem level. Moreover, the Linux Virtual file system support various hardening mechanisms
that can be set using sysctl.</description>
      <Group id="installation-storage-partitioning">
        <title>Partitioning</title>
        <description>
  Separating various locations of the file systems in different partitions allows a more restrictive
  segregation, distinctly from one location to another. Moreover, some native restrictions can be made by
partitioning, such as no hard link between different filesystems, and reduce the corruption impact to the
affected filesystem instead of the entire system. The last gain is to allow a differenciated usage of storage
media, depending on the operational needs (speed, resilience, etc.).
</description>
        <reference href="http://www.pathname.com/fhs/">Filesystem Hierarchy Standard</reference>
        <Rule id="partition_for_tmp">
          <title>Ensure /tmp Located On Separate Partition</title>
          <description>
The <tt>/tmp</tt> directory is a world-writable directory used
for temporary file storage. Ensure it has its own partition or
logical volume at installation time, or migrate it using LVM (when non-ephemeral is needed) or use tmpfs if possible.
</description>
          <!--
<fixtext ffixref="partition_for_tmp_fix">
  When tmpfs is possible, just add a specific tmpfs line on the <h:code>fstab</h:code> file (or via systemd), and specify the maximum
  associated size by using <h:code>size=</h:code> argument.
</fixtext>
-->
          <rationale>
The <tt>/tmp</tt> partition is used as temporary storage by many programs.
Placing <tt>/tmp</tt> in its own partition enables the setting of more
restrictive mount options, which can help protect programs which use it.
</rationale>
          <ocil>
            <partition-check-macro part="/tmp "/>
          </ocil>
          <oval id="partition_for_tmp"/>
          <ref nist="SC-32" anssi="NT28(R12)"/>
        </Rule>
        <Rule id="partition_for_var">
          <title>Ensure /var Located On Separate Partition</title>
          <description>The <tt>/var</tt> directory is used by daemons and other system
services to store frequently-changing data. Ensure that <tt>/var</tt> has its own partition
or logical volume at installation time, or migrate it using LVM.
</description>
          <ocil>
            <partition-check-macro part="/var "/>
          </ocil>
          <rationale>
Ensuring that <tt>/var</tt> is mounted on its own partition enables the
setting of more restrictive mount options. This helps protect
system services such as daemons or other programs which use it.
It is not uncommon for the <tt>/var</tt> directory to contain
world-writable directories installed by other software packages.
</rationale>
          <oval id="partition_for_var"/>
          <ref nist="SC-32" anssi="NT28(R12)"/>
        </Rule>
        <Rule id="partition_for_var_log">
          <title>Ensure /var/log Located On Separate Partition</title>
          <description>
System logs are stored in the <tt>/var/log</tt> directory.
Ensure that it has its own partition or logical
volume at installation time, or migrate it using LVM.
</description>
          <ocil>
            <partition-check-macro part="/var/log "/>
          </ocil>
          <rationale>
Placing <tt>/var/log</tt> in its own partition
enables better separation between log files
and other files in <tt>/var/</tt>.
</rationale>
          <oval id="partition_for_var_log"/>
          <ref nist="AU-9,SC-32" disa="" anssi="NT28(R12),NT28(R47)"/>
        </Rule>
        <Rule id="partition_for_var_log_audit">
          <title>Ensure /var/log/audit Located On Separate Partition</title>
          <description>
Audit logs are stored in the <tt>/var/log/audit</tt> directory.  Ensure that it
has its own partition or logical volume at installation time, or migrate it
later using LVM. Make absolutely certain that it is large enough to store all
audit logs that will be created by the auditing daemon.
</description>
          <ocil>
            <partition-check-macro part="/var/log/audit "/>
          </ocil>
          <rationale>
Placing <tt>/var/log/audit</tt> in its own partition
enables better separation between audit files
and other files, and helps ensure that
auditing cannot be halted due to the partition running out
of space.
</rationale>
          <oval id="partition_for_var_log_audit"/>
          <ref nist="AU-4,AU-9,SC-32" disa=""/>
        </Rule>
        <Rule id="partition_for_home">
          <title>Ensure /home Located On Separate Partition</title>
          <description>
If user home directories will be stored locally, create a separate partition
for <tt>/home</tt> at installation time (or migrate it later using LVM). If
<tt>/home</tt> will be mounted from another system such as an NFS server, then
creating a separate partition is not necessary at installation time, and the
mountpoint can instead be configured later.
</description>
          <ocil>
            <partition-check-macro part="/home "/>
          </ocil>
          <rationale>
Ensuring that <tt>/home</tt> is mounted on its own partition enables the
setting of more restrictive mount options, and also helps ensure that
users cannot trivially fill partitions used for log or audit data storage.
</rationale>
          <oval id="partition_for_home"/>
          <ref nist="SC-32" disa="1208" anssi="NT28(R12)"/>
        </Rule>
        <Rule id="partition_for_srv">
          <title>Ensure /srv Located On Separate Partition</title>
          <description>
If a file server (FTP, TFTP...) is hosted locally, create a separate partition
for <tt>/srv</tt> at installation time (or migrate it later using LVM). If
<tt>/srv</tt> will be mounted from another system such as an NFS server, then
creating a separate partition is not necessary at installation time, and the
mountpoint can instead be configured later.
</description>
          <ocil>
            <partition-check-macro part="/home "/>
          </ocil>
          <rationale>
Srv deserves files for local network file server such as FTP. Ensuring
that <tt>/srv</tt> is mounted on its own partition enables the setting of
more restrictive mount options, and also helps ensure that
users cannot trivially fill partitions used for log or audit data storage.
</rationale>
          <oval id="partition_for_srv"/>
          <ref anssi="NT28(R12)"/>
        </Rule>
      </Group>
      <Group id="fs-restrict">
        <title>filesystem rights management</title>
        <description>Adding filesystem specific hardening seriously limits various exploitation vectors based on
  filesystem invalid usage, such as invalid file types in invalid places (devices or setuid root files in external
media, executable file in insecure filesystems, etc.). Some of these hardening require an efficient system
partitioning.</description>
        <Rule id="sysctl_fs_protected_symlinks">
          <title>Disallow creating symlinks to a file you not own</title>
          <description>
            <sysctl-desc-macro sysctl="fs.protected_symlinks" value="1"/>
          </description>
          <ocil>
            <sysctl-check-macro sysctl="fs.protected_symlinks" value="1"/>
          </ocil>
          <rationale>Disallowing such symlink mitigate vulnerabilities based on insecure file system
accessed by privilegied programs, avoiding an exploitation vector exploiting unsafe use of
<tt>open()</tt> or <tt>creat()</tt>.</rationale>
          <oval id="sysctl_fs_protected_symlinks"/>
          <ref nist="SI-11" cis="1.6.1" anssi="NT28(R23)"/>
        </Rule>
        <Rule id="sysctl_fs_protected_hardlinks">
          <title>Disallow creating symlinks to a file you not own</title>
          <description>
            <sysctl-desc-macro sysctl="fs.protected_hardlinks" value="1"/>
          </description>
          <ocil>
            <sysctl-check-macro sysctl="fs.protected_hardlinks" value="1"/>
          </ocil>
          <rationale>Disallowing such hardlink mitigate vulnerabilities based on insecure file system
accessed by privilegied programs, avoiding an exploitation vector exploiting unsafe use of
<tt>open()</tt> or <tt>creat()</tt>.</rationale>
          <oval id="sysctl_fs_protected_hardlinks"/>
          <ref nist="SI-11" cis="1.6.1" anssi="NT28(R23)"/>
        </Rule>
      </Group>
    </Group>
    <Group id="accounts" prodtype="all">
      <title>Account and Access Control</title>
      <description>In traditional Unix security, if an attacker gains
shell access to a certain login account, they can perform any action
or access any file to which that account has access. Therefore,
making it more difficult for unauthorized people to gain shell
access to accounts, particularly to privileged accounts, is a
necessary part of securing a system. This section introduces
mechanisms for restricting access to accounts under
<product-name-macro/>.</description>
      <Group id="accounts-restrictions" prodtype="all">
        <title>Protect Accounts by Restricting Password-Based Login</title>
        <description>Conventionally, Unix shell accounts are accessed by
providing a username and password to a login program, which tests
these values for correctness using the <tt>/etc/passwd</tt> and
<tt>/etc/shadow</tt> files. Password-based login is vulnerable to
guessing of weak passwords, and to sniffing and man-in-the-middle
attacks against passwords entered over a network or at an insecure
console. Therefore, mechanisms for accessing accounts by entering
usernames and passwords should be restricted to those which are
operationally necessary.</description>
      </Group>
    </Group>
    <Group id="logging">
      <title>Configure Syslog</title>
      <description>The syslog service has been the default Unix logging mechanism for
many years. It has a number of downsides, including inconsistent log format,
lack of authentication for received messages, and lack of authentication,
encryption, or reliable transport for messages sent over a network. However,
due to its long history, syslog is a de facto standard which is supported by
almost all Unix applications.
<br/>
<br/>
In Ubuntu 1404, rsyslog has replaced syslog as the syslog daemon of choice,
and it includes some additional security features such as reliable,
connection-oriented (i.e. TCP) transmission of logs, the option to log to
database formats, and the encryption of log data en route to
a central logging server. This section discusses how to configure rsyslog for
best effect, and how to use tools provided with the system to maintain and
monitor logs.</description>
      <Rule id="package_rsyslog_installed" severity="medium">
        <title>Ensure rsyslog is Installed</title>
        <description>
Rsyslog is installed by default. 
<apt-get-macro install="true" package="rsyslog"/>
</description>
        <ocil clause="the package is not installed">
          <package-check-macro package="rsyslog"/>
        </ocil>
        <rationale>
The rsyslog package provides the rsyslog daemon, which provides
system logging services.
</rationale>
        <oval id="package_rsyslog_installed"/>
        <ref nist="AU-9(2)" disa="1311,1312" cis="5.1.1" anssi="NT28(R46)"/>
      </Rule>
      <Rule id="service_rsyslog_enabled" severity="medium">
        <title>Enable rsyslog Service</title>
        <description>The <tt>rsyslog</tt> service provides syslog-style logging by default on Ubuntu 1404.
<chkconfig-service-macro enable="true" service="rsyslog"/>
</description>
        <ocil>
          <service-check-macro enable="true" service="rsyslog"/>
        </ocil>
        <rationale>The <tt>rsyslog</tt> service must be running in order to provide
logging services, which are essential to system administration.
</rationale>
        <oval id="service_rsyslog_enabled"/>
        <ref nist="AU-4(1),AU-12" disa="1311,1312,1557,1851" cis="5.1.2" anssi="NT28(R46)"/>
      </Rule>
      <Group id="ensure_rsyslog_log_file_configuration">
        <title>Ensure Proper Configuration of Log Files</title>
        <description>
The file <tt>/etc/rsyslog.conf</tt> controls where log message are written.
These are controlled by lines called <i>rules</i>, which consist of a
<i>selector</i> and an <i>action</i>.
These rules are often customized depending on the role of the system, the
requirements of the environment, and whatever may enable
the administrator to most effectively make use of log data.
The default rules in Ubuntu 1404 are:
<pre>auth,authpriv.*			/var/log/auth.log
*.*;auth,authpriv.none          -/var/log/syslog
daemon.*                        -/var/log/daemon.log
kern.*                          -/var/log/kern.log
lpr.*                           -/var/log/lpr.log
mail.*                          -/var/log/mail.log
user.*                          -/var/log/user.log
mail.info                       -/var/log/mail.info
mail.warn                       -/var/log/mail.warn
mail.err                        /var/log/mail.err
news.crit                       /var/log/news/news.crit
news.err                        /var/log/news/news.err
news.notice                     -/var/log/news/news.notice
</pre>
See the man page <tt>rsyslog.conf(5)</tt> for more information.
<i>Note that the <tt>rsyslog</tt> daemon is configured to use traditional timestamping
to be understood by any log processing program. For high precision timestamping,
comment the following line in <tt>/etc/rsyslog.conf</tt>:
<pre>$ ActionFileDefaultTemplate RSYSLOG_TraditionalFileFormat</pre>
</i>
</description>
        <!-- These values are not currently used. -->
        <Value id="file_owner_logfiles_value" type="string" operator="equals" interactive="0">
          <title>User who owns log files</title>
          <description>Specify user owner of all logfiles specified in
<tt>/etc/rsyslog.conf</tt>.</description>
          <value selector="root">root</value>
        </Value>
        <Value id="file_groupowner_logfiles_value" type="string" operator="equals" interactive="0">
          <title>group who owns log files</title>
          <description>Specify group owner of all logfiles specified in
<tt>/etc/rsyslog.conf.</tt></description>
          <value selector="adm">adm</value>
        </Value>
        <Rule id="rsyslog_files_ownership" severity="medium">
          <title>Ensure Log Files Are Owned By Appropriate User</title>
          <description>The owner of all log files written by
<tt>rsyslog</tt> should be root.
These log files are determined by the second part of each Rule line in
<tt>/etc/rsyslog.conf</tt> and typically all appear in <tt>/var/log</tt>.
For each log file <i>LOGFILE</i> referenced in <tt>/etc/rsyslog.conf</tt>,
run the following command to inspect the file's owner:
<pre>$ ls -l <i>LOGFILE</i></pre>
If the owner is not <tt>root</tt>, run the following command to
correct this:
<pre>$ sudo chown root <i>LOGFILE</i></pre>
</description>
          <ocil clause="the owner is not root">
The owner of all log files written by <tt>rsyslog</tt> should be root.
These log files are determined by the second part of each Rule line in
<tt>/etc/rsyslog.conf</tt> and typically all appear in <tt>/var/log</tt>.
To see the owner of a given log file, run the following command:
<pre>$ ls -l <i>LOGFILE</i></pre>
</ocil>
          <rationale>The log files generated by rsyslog contain valuable information regarding system
configuration, user authentication, and other such information. Log files should be
protected from unauthorized access.</rationale>
          <oval id="rsyslog_files_ownership"/>
          <ref nist="AC-6,SI-11" disa="1314" pcidss="Req-10.5.1,Req-10.5.2" anssi="NT28(R46)"/>
        </Rule>
        <Rule id="rsyslog_files_groupownership" severity="medium">
          <title>Ensure Log Files Are Owned By Appropriate Group</title>
          <description>The group-owner of all log files written by
<tt>rsyslog</tt> should be root.
These log files are determined by the second part of each Rule line in
<tt>/etc/rsyslog.conf</tt> and typically all appear in <tt>/var/log</tt>.
For each log file <i>LOGFILE</i> referenced in <tt>/etc/rsyslog.conf</tt>,
run the following command to inspect the file's group owner:
<pre>$ ls -l <i>LOGFILE</i></pre>
If the owner is not <tt>adm</tt>, run the following command to
correct this:
<pre>$ sudo chgrp adm <i>LOGFILE</i></pre>
</description>
          <ocil clause="the group-owner is not adm">
The group-owner of all log files written by <tt>rsyslog</tt> should be adm.
These log files are determined by the second part of each Rule line in
<tt>/etc/rsyslog.conf</tt> and typically all appear in <tt>/var/log</tt>.
To see the group-owner of a given log file, run the following command:
<pre>$ ls -l <i>LOGFILE</i></pre>
</ocil>
          <rationale>The log files generated by rsyslog contain valuable information regarding system
configuration, user authentication, and other such information. Log files should be
protected from unauthorized access.</rationale>
          <oval id="rsyslog_files_groupownership"/>
          <ref nist="AC-6,SI-11" disa="1314" pcidss="Req-10.5.1,Req-10.5.2" anssi="NT28(R46)"/>
        </Rule>
        <Rule id="rsyslog_files_permissions" severity="medium">
          <title>Ensure System Log Files Have Correct Permissions</title>
          <description>The file permissions for all log files written by
<tt>rsyslog</tt> should be set to 640, or more restrictive.
These log files are determined by the second part of each Rule line in
<tt>/etc/rsyslog.conf</tt> and typically all appear in <tt>/var/log</tt>. 
For each log file <i>LOGFILE</i> referenced in <tt>/etc/rsyslog.conf</tt>,
run the following command to inspect the file's permissions:
<pre>$ ls -l <i>LOGFILE</i></pre>
If the permissions are not 640 or more restrictive,
run the following command to correct this:
<pre>$ sudo chmod 0640 <i>LOGFILE</i></pre>
</description>
          <ocil clause="the permissions are not correct">
The file permissions for all log files written by <tt>rsyslog</tt> 
should be set to 640, or more restrictive.
These log files are determined by the second part of each Rule line in
<tt>/etc/rsyslog.conf</tt> and typically all appear in <tt>/var/log</tt>.
To see the permissions of a given log file, run the following command:
<pre>$ ls -l <i>LOGFILE</i></pre>
The permissions should be 640, or more restrictive.
</ocil>
          <rationale>Log files can contain valuable information regarding system
configuration. If the system log files are not protected unauthorized
users could change the logged data, eliminating their forensic value.
</rationale>
          <oval id="rsyslog_files_permissions"/>
          <ref nist="SI-11" disa="1314" pcidss="Req-10.5.1,Req-10.5.2" cis="5.1.4" anssi="NT28(R36)"/>
        </Rule>
      </Group>
      <Group id="rsyslog_sending_messages">
        <title>Rsyslog Logs Sent To Remote Host</title>
        <description>
If system logs are to be useful in detecting malicious
activities, it is necessary to send logs to a remote server. An
intruder who has compromised the root account on a machine may
delete the log entries which indicate that the system was attacked
before they are seen by an administrator.
<br/><br/>
However, it is recommended that logs be stored on the local
host in addition to being sent to the loghost, especially if
<tt>rsyslog</tt> has been configured to use the UDP protocol to send
messages over a network. UDP does not guarantee reliable delivery,
and moderately busy sites will lose log messages occasionally,
especially in periods of high traffic which may be the result of an
attack. In addition, remote <tt>rsyslog</tt> messages are not
authenticated in any way by default, so it is easy for an attacker to
introduce spurious messages to the central log server. Also, some
problems cause loss of network connectivity, which will prevent the
sending of messages to the central server. For all of these reasons, it is
better to store log messages both centrally and on each host, so
that they can be correlated if necessary.</description>
        <Rule id="rsyslog_remote_loghost">
          <title>Ensure Logs Sent To Remote Host</title>
          <description>
To configure rsyslog to send logs to a remote log server,
open <tt>/etc/rsyslog.conf</tt> and read and understand the last section of the file,
which describes the multiple directives necessary to activate remote
logging.
Along with these other directives, the system can be configured
to forward its logs to a particular log server by
adding or correcting one of the following lines,
substituting <tt><i>loghost.example.com</i></tt> appropriately.
The choice of protocol depends on the environment of the system; 
although TCP and RELP provide more reliable message delivery, 
they may not be supported in all environments.
<br/>
To use UDP for log message delivery:
<pre>*.* @<i>loghost.example.com</i></pre>
<br/>
To use TCP for log message delivery:
<pre>*.* @@<i>loghost.example.com</i></pre>
<br/>
To use RELP for log message delivery:
<pre>*.* :omrelp:<i>loghost.example.com</i></pre>
</description>
          <ocil clause="none of these are present">
To ensure logs are sent to a remote host, examine the file
<tt>/etc/rsyslog.conf</tt>.
If using UDP, a line similar to the following should be present:
<pre> *.* @<i>loghost.example.com</i></pre>
If using TCP, a line similar to the following should be present:
<pre> *.* @@<i>loghost.example.com</i></pre>
If using RELP, a line similar to the following should be present:
<pre> *.* :omrelp:<i>loghost.example.com</i></pre>
</ocil>
          <rationale>A log server (loghost) receives syslog messages from one or more
systems. This data can be used as an additional log source in the event a
system is compromised and its local logs are suspect. Forwarding log messages
to a remote loghost also provides system administrators with a centralized
place to view the status of multiple hosts within the enterprise.
</rationale>
          <oval id="rsyslog_remote_loghost"/>
          <ref nist="AU-3(2),AU-4(1),AU-9" disa="1348,136,1851" cis="5.1.5"/>
        </Rule>
      </Group>
      <Group id="rsyslog_accepting_remote_messages">
        <title>Configure <tt>rsyslogd</tt> to Accept Remote Messages If Acting as a Log Server</title>
        <description>
By default, <tt>rsyslog</tt> does not listen over the network
for log messages. If needed, modules can be enabled to allow
the rsyslog daemon to receive messages from other systems and for the system
thus to act as a log server.
If the machine is not a log server, then lines concerning these modules
should remain commented out.
<br/><br/>
</description>
        <Rule id="rsyslog_accept_remote_messages_tcp">
          <title>Enable rsyslog to Accept Messages via TCP, if Acting As Log Server</title>
          <description>The <tt>rsyslog</tt> daemon should not accept remote messages
unless the system acts as a log server.
If the system needs to act as a central log server, add the following lines to
<tt>/etc/rsyslog.conf</tt> to enable reception of messages over TCP:
<pre>$ModLoad imtcp
$InputTCPServerRun 514</pre>
</description>
          <rationale>
If the system needs to act as a log server, this ensures that it can receive
messages over a reliable TCP connection.
</rationale>
          <!--<oval id="rsyslog_listen_tcp" />-->
          <ref nist="AU-9" cis="5.1.6"/>
        </Rule>
        <Rule id="rsyslog_accept_remote_messages_udp">
          <title>Enable rsyslog to Accept Messages via UDP, if Acting As Log Server</title>
          <description>The <tt>rsyslog</tt> daemon should not accept remote messages
unless the system acts as a log server.
If the system needs to act as a central log server, add the following lines to
<tt>/etc/rsyslog.conf</tt> to enable reception of messages over UDP:
<pre>$ModLoad imudp
$UDPServerRun 514</pre>
</description>
          <rationale>
Many devices, such as switches, routers, and other Unix-like systems, may only support
the traditional syslog transmission over UDP. If the system must act as a log server,
this enables it to receive their messages as well.
</rationale>
          <ref nist="AU-9" cis="5.1.6"/>
        </Rule>
      </Group>
      <Group id="log_rotation">
        <title>Ensure All Logs are Rotated by <tt>logrotate</tt></title>
        <description>Edit the file <tt>/etc/logrotate.d/rsyslog</tt>. Find the first
line, which should look like this (wrapped for clarity):
<pre>/var/log/messages /var/log/secure /var/log/maillog /var/log/spooler \
  /var/log/boot.log /var/log/cron {</pre>
Edit this line so that it contains a one-space-separated
listing of each log file referenced in <tt>/etc/rsyslog.conf</tt>.
<br/><br/>
All logs in use on a system must be rotated regularly, or the
log files will consume disk space over time, eventually interfering
with system operation. The file <tt>/etc/logrotate.d/syslog</tt> is the
configuration file used by the <tt>logrotate</tt> program to maintain all
log files written by <tt>syslog</tt>. By default, it rotates logs weekly and
stores four archival copies of each log. These settings can be
modified by editing <tt>/etc/logrotate.conf</tt>, but the defaults are
sufficient for purposes of this guide.
<br/><br/>
Note that <tt>logrotate</tt> is run nightly by the cron job
<tt>/etc/cron.daily/logrotate</tt>. If particularly active logs need to be
rotated more often than once a day, some other mechanism must be
used.</description>
        <Rule id="ensure_logrotate_activated">
          <title>Ensure Logrotate Runs Periodically</title>
          <description>The <tt>logrotate</tt> utility allows for the automatic rotation of 
log files.  The frequency of rotation is specified in <tt>/etc/logrotate.conf</tt>, 
which triggers a cron task.  To configure logrotate to run daily, add or correct 
the following line in <tt>/etc/logrotate.conf</tt>:
<pre># rotate log files <i>frequency</i>
daily</pre>
</description>
          <rationale>Log files that are not properly rotated run the risk of growing so large
that they fill up the /var/log partition. Valuable logging information could be lost
if the /var/log partition becomes full.</rationale>
          <ocil clause="logrotate is not configured to run daily">
To determine the status and frequency of logrotate, run the following command:
<pre>$ sudo grep logrotate /var/log/cron*</pre>
If logrotate is configured properly, output should include references to 
<tt>/etc/cron.daily</tt>.
</ocil>
          <oval id="ensure_logrotate_activated"/>
          <ref nist="AU-9" disa="366" pcidss="Req-10.7"/>
        </Rule>
      </Group>
    </Group>
  </Group>
  <Group id="services" prodtype="all">
    <title>Services</title>
    <description>
The best protection against vulnerable software is running less software. This section describes how to review
the software which <product-name-macro/> installs on a system and disable software which is not needed. It
then enumerates the software packages installed on a default <product-name-macro/> system and provides guidance about which
ones can be safely disabled.
<br/><br/>
<product-name-macro/> provides a convenient minimal install option that essentially installs the bare necessities for a functional
system. When building <product-name-macro/> systems, it is highly recommended to select the minimal packages and then build up
the system from there.
</description>
    <Group id="deprecated">
      <title>Deprecated services</title>
      <description>
Some deprecated software services impact the overall system security due to their behavior (leak of
confidentiality in network exchange, usage as uncontrolled communication channel, risk associated with the service due to its old age, etc.
</description>
      <Rule id="package_telnetd_removed" severity="high">
        <title>Uninstall the telnet server</title>
        <description>
The telnet daemon should be uninstalled.
</description>
        <rationale>
telnet allows clear text communications, and does not protect any data transmission between client and server. Any confidential data can be listened and no integrity checking is made. 
</rationale>
        <ident cce=""/>
        <oval id="package_telnetd_removed"/>
        <ref nist="AC-17(8),CM-7" disa="" anssi="NT007(R03)"/>
      </Rule>
      <Rule id="package_inetutils-telnetd_removed" severity="high">
        <title>Uninstall the inet-based telnet server</title>
        <description>
The inet-based telnet daemon should be uninstalled.
</description>
        <rationale>
telnet allows clear text communications, and does not protect any data transmission between client and server. Any confidential data can be listened and no integrity checking is made. 
</rationale>
        <ident cce=""/>
        <oval id="package_inetutils-telnetd_removed"/>
        <ref nist="AC-17(8),CM-7" disa="" anssi="NT007(R03)"/>
      </Rule>
      <Rule id="package_telnetd-ssl_removed" severity="high">
        <title>Uninstall the ssl compliant telnet server</title>
        <description>
The telnet daemon, even with ssl support, should be uninstalled.
</description>
        <rationale>
telnet, even with ssl support, should not be installed. When remote shell is required, up-to-date ssh daemon can be used.
</rationale>
        <ident cce=""/>
        <oval id="package_telnetd-ssl_removed"/>
        <ref nist="AC-17(8),CM-7" anssi="NT007(R02)"/>
      </Rule>
      <Rule id="package_nis_removed" severity="low">
        <title>Uninstall the nis package</title>
        <description>
The support for Yellowpages should not be installed unless it is required.
</description>
        <rationale>
NIS is the historical SUN service for central account management, more and more replaced by LDAP.
NIS does not support efficiently security constraints, ACL, etc. and should not be used.
</rationale>
        <ident cce=""/>
        <oval id="package_nis_removed"/>
        <!-- <ref nist="AC-17(8),CM-7" disa=""/> -->
      </Rule>
      <Rule id="package_ntpdate_removed" severity="low">
        <title>Uninstall the ntpdate package</title>
        <description>
ntpdate is a historical ntp synchronization client for unixes. It sould be uninstalled.
</description>
        <rationale>
ntpdate is an old not security-compliant ntp client. It should be replaced by modern ntp clients such as ntpd, able to use cryptographic mechanisms integrated in NTP.
</rationale>
        <ident cce=""/>
        <oval id="package_ntpdate_removed"/>
        <!-- <ref nist="AC-17(8),CM-7" disa=""/> -->
      </Rule>
      <!--
TODO: 
prelink
rsh-client
rsh-server
talk
talkd
-->
    </Group>
    <Group id="basics">
      <title>Generic required services</title>
      <description>
Some services need to be deployed in order to ensure basic verifications and reporting on GNU/Linux operating systems.
Each of these service take part in the administrability of the system.
</description>
      <Rule id="package_auditd_installed" severity="medium">
        <title>install the auditd service</title>
        <description>
The auditd service should be installed.
</description>
        <rationale>
The auditd service is an access monitoring and accounting daemon, watching system calls to audit any access, in comparision with potential local access control policy such as SELinux policy.
</rationale>
        <ident cce=""/>
        <oval id="package_auditd_installed"/>
        <ref anssi="NT28(R50)"/>
      </Rule>
      <Rule id="service_auditd_enabled" severity="medium">
        <title>Enable the auditd service</title>
        <description>
The auditd service should be enabled.
</description>
        <rationale>
The auditd service is an access monitoring and accounting daemon, watching system calls to audit any access, in comparision with potential local access control policy such as SELinux policy.
</rationale>
        <ocil>
          <service-check-macro enable="true" service="auditd"/>
        </ocil>
        <ident cce=""/>
        <oval id="service_auditd_enabled"/>
        <ref anssi="NT28(R50)" nist="AC-17(1),AU-1(b),AU-10,AU-12(a),AU-12(c),IR-5" disa="347,157,172,880,1353,1462,1487,1115,1454,067,158,831,1190,1312,1263,130,120,1589" pcidss="Req-10"/>
      </Rule>
      <Rule id="package_cron_installed" severity="medium">
        <title>Install the cron service</title>
        <description>
The Cron service should be installed.
</description>
        <rationale>
The cron service allow periodic job execution, needed for almost all administrative tasks and services (software update, log rotating, etc.). Access to cron service should be restricted to administrative accounts only.
</rationale>
        <ident cce=""/>
        <oval id="package_cron_installed"/>
        <ref nist="CM-7" anssi="NT28(R50)"/>
      </Rule>
      <Rule id="service_cron_enabled" severity="medium">
        <title>Enable the cron service</title>
        <description>
The Cron service should be enabled.
</description>
        <rationale>
The cron service allow periodic job execution, needed for almost all administrative tasks and services (software update, log rotating, etc.). Access to cron service should be restricted to administrative accounts only.
</rationale>
        <ident cce=""/>
        <oval id="service_cron_enabled"/>
        <ref nist="CM-7"/>
      </Rule>
      <Rule id="package_ntp_installed" severity="high">
        <title>Install the ntp service</title>
        <description>
The ntpd service should be installed.
</description>
        <rationale>
Time synchronization (using NTP) is required by almost all network and administrative tasks (syslog, cryptographic based services (authentication, etc.), etc.). Ntpd is regulary maintained and updated, supporting security features such as RFC 5906.
</rationale>
        <ident cce=""/>
        <oval id="package_ntp_installed"/>
        <ref nist="AU-8(1)" disa="160" pcidss="Req-10.4" anssi="NT012(R03)"/>
      </Rule>
      <Rule id="service_ntpd_enabled" severity="high">
        <title>Enable the ntpd service</title>
        <description>
The ntpd service should be enabled.
</description>
        <rationale>
Time synchronization (using NTP) is required by almost all network and administrative tasks (syslog, cryptographic based services (authentication, etc.), etc.). Ntpd is regulary maintained and updated, supporting security features such as RFC 5906.
</rationale>
        <ocil>
          <service-check-macro enable="true" service="ntpd"/>
        </ocil>
        <ident cce=""/>
        <oval id="service_ntpd_enabled"/>
        <ref nist="AU-8(1)" disa="160" pcidss="Req-10.4" anssi="NT012(R03)"/>
      </Rule>
    </Group>
    <Group id="apt">
      <title>APT service configuration</title>
      <description>The apt service manage the package management and update of the whole system. Its configuration need to be properly defined to ensure efficient security updates, packages and repository authentication and proper lifecycle management.
  </description>
      <Rule id="apt_conf_disallow_unauthenticated">
        <title>Disable unauthenticated repositories in APT configuration</title>
        <description>Unauthenticated repositories should not be used for updates.</description>
        <rationale>
    Repositories hosts all packages that will be intsalled on the system during update.
    If a repository is not authenticated, the associated packages can't be trusted,
    and then should not be installed localy.
  </rationale>
        <oval id="apt_conf_disallow_unauthenticated"/>
        <ref anssi="NT28(R15)"/>
      </Rule>
    </Group>
    <Group id="ssh">
      <title>SSH Server</title>
      <description>The SSH protocol is recommended for remote access (remote login and secure remote file transfer).
SSH provides both confidentiality and integrity for exchanged data but needs to be configured properly in term of:<br/>
Cryptography usage, according to the current CVEs associated to the various cryptographic modes<br/>
Authentication and autorization, depending on your needs but requiring some specific initial generic security<br/>
consideration in the OpenSSH configuration writing
More detailed information is available from the OpenSSH project's website <weblink-macro link="http://www.openssh.org"/>. The Ubuntu package for
server side implementation is called <tt>openssh-server</tt>.
</description>
      <Value id="sshd_idle_timeout_value" type="number" operator="equals" interactive="0">
        <title>SSH session Idle time</title>
        <description>Specify duration of allowed idle time.</description>
        <value selector="">300</value>
        <value selector="5_minutes">300</value>
        <value selector="10_minutes">600</value>
        <value selector="15_minutes">900</value>
        <value selector="60_minutes">3600</value>
        <value selector="120_minutes">7200</value>
      </Value>
      <Rule id="service_sshd_disabled">
        <title>Disable SSH Server if possible (unusual cases)</title>
        <description>Most of the time, the SSH server is needed. However, it can be disabled, do so.
<chkconfig-service-macro enable="false" service="ssh"/>
This is unusual, as SSH is a common method for encrypted and authenticated
remote access.
</description>
        <oval id="service_sshd_disabled"/>
      </Rule>
      <Group id="ssh_server">
        <title>Configure OpenSSH Server if deployed</title>
        <description>If the system needs to act as an SSH server, then
certain changes should be made to the OpenSSH daemon configuration
file <tt>/etc/ssh/sshd_config</tt>. The following recommendations can be
applied to this file. See the <tt>sshd_config(5)</tt> man page for more
detailed information.</description>
        <Rule id="sshd_allow_only_protocol2" severity="high">
          <title>Allow Only SSH Protocol 2</title>
          <description>Only SSH protocol version 2 connections should be
permitted. The default setting in
<tt>/etc/ssh/sshd_config</tt> is correct, and can be
verified by ensuring that the following
line appears:
<pre>Protocol 2</pre>
</description>
          <ocil clause="it is not">
To check which SSH protocol version is allowed, run the following command:
<pre>$ sudo grep Protocol /etc/ssh/sshd_config</pre>
If configured properly, output should be <pre>Protocol 2</pre>
</ocil>
          <rationale>
SSH protocol version 1 suffers from design flaws that
result in security vulnerabilities and
should not be used.
</rationale>
          <ident cce=""/>
          <oval id="sshd_allow_only_protocol2"/>
          <ref nist="AC-17(7),IA-5(1)(c)" anssi="NT007(R1)"/>
        </Rule>
        <Rule id="sshd_set_idle_timeout">
          <title>Set SSH Idle Timeout Interval</title>
          <description>SSH allows administrators to set an idle timeout interval.
After this interval has passed, the idle user will be automatically logged out.
<br/><br/>
To set an idle timeout interval, edit the following line in <tt>/etc/ssh/sshd_config</tt> as
follows:
<pre>ClientAliveInterval <b>interval</b></pre>
The timeout <b>interval</b> is given in seconds. To have a timeout
of 15 minutes, set <b>interval</b> to 900.
<br/><br/>
If a shorter timeout has already been set for the login
shell, that value will preempt any SSH
setting made here. Keep in mind that some processes may stop SSH
from correctly detecting that the user is idle.
</description>
          <ocil clause="it is not">
Run the following command to see what the timeout interval is:
<pre>$ sudo grep ClientAliveInterval /etc/ssh/sshd_config</pre>
If properly configured, the output should be:
<pre>ClientAliveInterval 900</pre>
</ocil>
          <rationale>
Causing idle users to be automatically logged out
guards against compromises one system leading trivially
to compromises on another.
</rationale>
          <ident cce=""/>
          <oval id="sshd_set_idle_timeout" value="sshd_idle_timeout_value"/>
          <ref nist="AC-2(5),SA-8" pcidss="Req-8.1.8"/>
        </Rule>
        <Rule id="sshd_set_keepalive">
          <title>Set SSH Client Alive Count</title>
          <description>To ensure the SSH idle timeout occurs precisely when the <tt>ClientAliveCountMax</tt> is set,
edit <tt>/etc/ssh/sshd_config</tt> as
follows:
<pre>ClientAliveCountMax 0</pre>
</description>
          <ocil clause="it is not">
To ensure the SSH idle timeout will occur when the <tt>ClientAliveCountMax</tt> is set, run the following command:
<pre>$ sudo grep ClientAliveCountMax /etc/ssh/sshd_config</pre>
If properly configured, output should be:
<pre>ClientAliveCountMax 0</pre>
</ocil>
          <rationale>
This ensures a user login will be terminated as soon as the <tt>ClientAliveCountMax</tt>
is reached.
</rationale>
          <ident cce=""/>
          <oval id="sshd_set_keepalive"/>
          <ref nist="AC-2(5),SA-8"/>
        </Rule>
        <Rule id="sshd_disable_root_login" severity="medium">
          <title>Disable SSH Root Login</title>
          <description>The root user should never be allowed to login to a
system directly over a network.
To disable root login via SSH, add or correct the following line
in <tt>/etc/ssh/sshd_config</tt>:
<pre>PermitRootLogin no</pre>
</description>
          <ocil>
            <sshd-check-macro option="PermitRootLogin" value="no" default="no"/>
          </ocil>
          <rationale>
Permitting direct root login reduces auditable information about who ran
privileged commands on the system
and also allows direct attack attempts on root's password.
</rationale>
          <ident cce=""/>
          <oval id="sshd_disable_root_login"/>
          <ref nist="AC-3,AC-6(2),IA-2(1)" anssi="NT007(R21)"/>
        </Rule>
        <Rule id="sshd_disable_empty_passwords" severity="high">
          <title>Disable SSH Access via Empty Passwords</title>
          <description>To explicitly disallow remote login from accounts with
empty passwords, add or correct the following line in
<tt>/etc/ssh/sshd_config</tt>:
<pre>PermitEmptyPasswords no</pre>
Any accounts with empty passwords should be disabled immediately, and PAM configuration
should prevent users from being able to assign themselves empty passwords.
</description>
          <ocil>
            <sshd-check-macro option="PermitEmptyPasswords" value="no" default="yes"/>
          </ocil>
          <rationale>
Configuring this setting for the SSH daemon provides additional assurance that
remote login via SSH will require a password,
even in the event of misconfiguration elsewhere.
</rationale>
          <ident cce=""/>
          <oval id="sshd_disable_empty_passwords"/>
          <ref nist="AC-3" anssi="NT007(R17)"/>
        </Rule>
      </Group>
    </Group>
  </Group>
</Benchmark>
